{"version":3,"sources":["src/ngx.leaflet.components.umd.js"],"names":["global","factory","exports","module","require","define","amd","ng","ngxLeafletComponents","core","Rx","http","Observable","prototype","common","this","map","_catch","__extends","d","b","__","constructor","extendStatics","Object","create","setPrototypeOf","__proto__","Array","p","hasOwnProperty","MapService","basemaps","overlays","layerControlflag","layersInControlNumber","layerControlObject","groupIdentifiers","groupNames","setMap","map$$1","getMap","setLayerControl","state","getLayerControl","addBasemap","basemap","name","undefined","getUniqueName","nameindex","newName","indexOf","parseInt","split","addOverlay","overlay","gId","index","existing_name","push","addControl","getBasemaps","getOverlays","getObservableOverlays","_this","observer","next","complete","getObservableBasemaps","refreshOverlays","remove","add","key","forEach","element","arr","_leaflet_id","increaseNumber","getLayerNumber","keys","length","getContainer","innerHTML","removeControl","L","control","layers","addTo","decorators","type","Injectable","ctorParameters","CoordinateHandler","assignCartesianPointToLeafletsLatLngSchema","x","lon","y","lat","assignCartesianArrayToLeafletsLatLngSchema","xys","i","reverse","latlngs","transformPointCoordinates","crs","code","newlatlng","unproject","setNewLatLng","lng","transformArrayCoordinates","trasformed","propDecorators","Input","LeafletElement","_super","mapService","call","zoom","minZoom","maxZoom","layerControl","CRS","EPSG3857","maxBounds","ngOnInit","splitCrs","console","warn","mapElement","nativeElement","zoomControl","center","latLng","closePopupOnClick","attributionControl","myMapProperty","ngAfterViewInit","Component","args","selector","template","styles","providers","ViewChild","GeoJSONCoordinateHandler","geojson","transformJSONCoordinates","geoJSON","features","feature","geometry","point","coordinates","polygonElement","lineString","polygon","geometries","attributionModel","options","prefix","position","AttributionControl","LeafletElement$$1","Options","attribution","Optional","scaleModel","maxWidth","metric","imperial","updateWhenIdle","source","copy","ScaleControl","scale","zoomModel","zoomInText","zoomInTitle","zoomOutText","zoomOutTitle","ZoomControl","WatermarkControl","self","url","Control","extend","onAdd","basediv","DomUtil","numberOfLogo","Math","ceil","getSize","imagewidth","imageheight","log","img","src","style","width","onRemove","opts","LayerElement","slippyLayer","wmsLayer","opacity","layer","tileLayer","wms","setOpacity","ImageOverlayElement","bounds","imagepath","imageOverlay","GuidService","newGuid","replace","c","r","random","toString","GroupService","guidService","layerGroup","layerId","layerGroupNumber","group","addOLayersToGroup","removeLayer","getLayerGroup","addLayer","getGroup","globalId","getObservableGroup","PopupService","enablePopup","mouseover","onclick","text","bindPopup","on","openPopup","closePopup","LeafletGroup","groupService","MarkerElement","popupService","http$$1","LeafletGroup$$1","iconUrl","marker","model","map_1","createMarkerlayer","imageExists","exists","getImage","subscribe","image","document","createElement","window","URL","createObjectURL","blob","reader","FileReader","onload","result","obj","icon","iconSize","height","iconAnchor","popupAnchor","readAsDataURL","err","textInput","ngEl","childNodes","nodeValue","callback","Image","onerror","headers","Headers","Content-Type","RequestOptions","responseType","ResponseContentType","Blob","get","res","catch","error","throw","Http","path","pathInfo","stroke","color","weight","lineCap","lineJoin","dashArray","dashOffset","fill","fillColor","fillOpacity","fillRule","className","CircleElement","radius","circle","inheritedOptions","CircleMarkerElement","circleMarker","HelperService","arrayCompare","a","PolygonElement","helperService","originalObject","slice","ngDoCheck","PolylineElement","polyline","GeoJsonElement","assign","gjson","PopupElement","content","popup","autoClose","keepInView","setLatLng","setContent","ngxLeafletModule","NgModule","imports","CommonModule","HttpModule","declarations","defineProperty","value"],"mappings":"CAAC,SAAUA,OAAQC,SACC,iBAAZC,SAA0C,oBAAXC,OAAyBF,QAAQC,QAASE,QAAQ,iBAAkBA,QAAQ,mBAAoBA,QAAQ,iBAAkBA,QAAQ,yBAA0BA,QAAQ,2BAA4BA,QAAQ,oBAC5N,mBAAXC,QAAyBA,OAAOC,IAAMD,QAAQ,UAAW,gBAAiB,kBAAmB,gBAAiB,wBAAyB,0BAA2B,mBAAoBJ,SAC5LA,SAASD,OAAOO,GAAKP,OAAOO,OAAUP,OAAOO,GAAGC,yBAA2BR,OAAOO,GAAGE,KAAKT,OAAOU,GAAGV,OAAOO,GAAGI,KAAKX,OAAOU,GAAGE,WAAWC,UAAUb,OAAOU,GAAGE,WAAWC,UAAUb,OAAOO,GAAGO,QAH7L,CAIEC,KAAM,SAAWb,QAAQO,KAAKG,WAAWD,KAAKK,IAAIC,OAAOH,QAAU,aAsBrE,SAASI,UAAUC,EAAGC,GAElB,SAASC,KAAON,KAAKO,YAAcH,EADnCI,cAAcJ,EAAGC,GAEjBD,EAAEN,UAAkB,OAANO,EAAaI,OAAOC,OAAOL,IAAMC,GAAGR,UAAYO,EAAEP,UAAW,IAAIQ,IAPnF,IAAIE,cAAgBC,OAAOE,iBACpBC,wBAA2BC,OAAS,SAAUT,EAAGC,GAAKD,EAAEQ,UAAYP,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIS,KAAKT,EAAOA,EAAEU,eAAeD,KAAIV,EAAEU,GAAKT,EAAES,KAYrEE,WAAc,WACd,SAASA,aACLhB,KAAKiB,YACLjB,KAAKkB,YACLlB,KAAKmB,kBAAmB,EACxBnB,KAAKoB,sBAAwB,EAC7BpB,KAAKqB,sBACLrB,KAAKsB,oBACLtB,KAAKuB,cAsOT,OAhOAP,WAAWlB,UAAU0B,OAIrB,SAAUC,QACNzB,KAAKC,IAAMwB,QAKfT,WAAWlB,UAAU4B,OAGrB,WACI,OAAO1B,KAAKC,KAMhBe,WAAWlB,UAAU6B,gBAIrB,SAAUC,OACN5B,KAAKmB,iBAAmBS,OAK5BZ,WAAWlB,UAAU+B,gBAGrB,WACI,OAAO7B,KAAKmB,kBAOhBH,WAAWlB,UAAUgC,WAKrB,SAAUC,QAASC,MACF,KAATA,OACAA,KAAO,sBAEiBC,IAAxBjC,KAAKiB,SAASe,MACdhC,KAAKiB,SAASe,MAAQD,SAGtBC,KAAOhC,KAAKkC,cAAcF,MAC1BhC,KAAK8B,WAAWC,QAASC,QAOjChB,WAAWlB,UAAUoC,cAIrB,SAAUF,MACN,IAAqBG,UAAY,EACZC,QAAUJ,KAS/B,OAR2B,IAAvBA,KAAKK,QAAQ,MACbF,UAAYG,SAASN,KAAKO,MAAM,KAAK,GAAGA,MAAM,KAAK,IACnDJ,WAAa,EACbC,QAAUJ,KAAKO,MAAM,KAAK,IAG1BJ,UAAY,EAETH,KAAOI,QAAU,IAAMD,UAAY,KAQ9CnB,WAAWlB,UAAU0C,WAMrB,SAAUC,QAAST,KAAMU,KACrB,IAA4C,IAAxC1C,KAAKsB,iBAAiBe,QAAQK,KAAa,CAC3C,IAAqBC,MAAQ3C,KAAKsB,iBAAiBe,QAAQK,KACtCE,cAAgB5C,KAAKuB,WAAWoB,OACrD3C,KAAKkB,SAAS0B,eAAiBH,YAGlB,KAATT,OACAA,KAAO,sBAEiBC,IAAxBjC,KAAKkB,SAASc,OACdhC,KAAKuB,WAAWsB,KAAKb,MACrBhC,KAAKsB,iBAAiBuB,KAAKH,KAC3B1C,KAAKkB,SAASc,MAAQS,UAGtBT,KAAOhC,KAAKkC,cAAcF,OACa,IAAnChC,KAAKuB,WAAWc,QAAQL,OACxBhC,KAAKuB,WAAWsB,KAAKb,MACrBhC,KAAKsB,iBAAiBuB,KAAKH,MAG3B1C,KAAKwC,WAAWC,QAAST,OAIrChC,KAAK8C,cAKT9B,WAAWlB,UAAUiD,YAGrB,WACI,OAAO/C,KAAKiB,UAKhBD,WAAWlB,UAAUkD,YAGrB,WACI,OAAOhD,KAAKkB,UAKhBF,WAAWlB,UAAUmD,sBAGrB,WACI,IAAIC,MAAQlD,KACZ,OAAOH,WAAWA,WAAWa,OAAO,SAAUyC,UAC1CA,SAASC,KAAKF,MAAMhC,UACpBiC,SAASE,cAMjBrC,WAAWlB,UAAUwD,sBAGrB,WACI,IAAIJ,MAAQlD,KACZ,OAAOH,WAAWA,WAAWa,OAAO,SAAUyC,UAC1CA,SAASC,KAAKF,MAAMjC,UACpBkC,SAASE,cAQjBrC,WAAWlB,UAAUyD,gBAKrB,SAAUC,OAAQC,KACd,IAAqBvC,SAAWlB,KAAKgD,cACrC,IAAK,IAAqBU,OAAOxC,SACzBA,SAASwC,eAAgB7C,OACzBK,SAASwC,KAAKC,QAAQ,SAAUC,QAASjB,MAAOkB,KACxCD,QAAQE,aAAeN,OAAOM,cAC9BD,IAAIlB,OAASc,QASjCzC,WAAWlB,UAAUiE,eAGrB,WACI/D,KAAKoB,uBAAyB,GAKlCJ,WAAWlB,UAAUkE,eAGrB,WACI,OAAOhE,KAAKoB,uBAKhBJ,WAAWlB,UAAUgD,WAGrB,WACI,GAAI9C,KAAKmB,iBAAkB,CACvB,IAAqBM,OAASzB,KAAK0B,SACiB,IAAhDjB,OAAOwD,KAAKjE,KAAKqB,oBAAoB6C,SACrClE,KAAKqB,mBAAmB8C,eAAeC,UAAY,GACnD3C,OAAO4C,cAAcrE,KAAKqB,qBAE9BrB,KAAKqB,mBAAqBiD,EAAEC,QAAQC,OAAOxE,KAAK+C,cAAe/C,KAAKgD,eAAeyB,MAAMhD,UAGjGT,WAAW0D,aACLC,KAAMjF,KAAKkF,aAGjB5D,WAAW6D,eAAiB,WAAc,UACnC7D,WA9OM,GAqPb8D,kBAAqB,WACrB,SAASA,qBAmHT,OA9GAA,kBAAkBhF,UAAUiF,2CAG5B,gBACmB9C,IAAXjC,KAAKgF,IACLhF,KAAKiF,IAAMjF,KAAKgF,QAEL/C,IAAXjC,KAAKkF,IACLlF,KAAKmF,IAAMnF,KAAKkF,IAOxBJ,kBAAkBhF,UAAUsF,2CAI5B,SAAUvB,KACN,QAAiB5B,IAAbjC,KAAKqF,IAAmB,CACnBxB,MACDA,IAAM7D,KAAKqF,KAEf,IAAK,IAAqBC,EAAI,EAAGA,EAAIzB,IAAIK,OAAQoB,IACrB,iBAAZzB,IAAI,GACZ7D,KAAKoF,2CAA2CvB,IAAIyB,IAGpDzB,IAAI0B,UAGZvF,KAAKwF,QAAUxF,KAAKqF,MAO5BP,kBAAkBhF,UAAU2F,0BAI5B,SAAUC,KAQN,GAAIA,IAAIC,MAAqB,cAAbD,IAAIC,KAAsB,CACjBC,UAAYF,IAAIG,WAAYX,EAAGlF,KAAKmF,IAAKH,EAAGhF,KAAKiF,MACtEjF,KAAK8F,aAAaF,eAEjB,CACD,IAAqBA,WAAcT,IAAKnF,KAAKmF,IAAKY,IAAK/F,KAAKiF,KAC5DjF,KAAK8F,aAAaF,aAO1Bd,kBAAkBhF,UAAUgG,aAI5B,SAAUF,WACN5F,KAAKmF,IAAMS,UAAUT,IACrBnF,KAAKiF,IAAMW,UAAUG,KAOzBjB,kBAAkBhF,UAAUkG,0BAK5B,SAAUN,IAAK7B,KACNA,MACDA,IAAM7D,KAAKwF,SAEf,IAAK,IAAqBF,EAAI,EAAGA,EAAIzB,IAAIK,OAAQoB,IAC7C,GAAwB,iBAAZzB,IAAI,GACZA,IAAIyB,GAAKtF,KAAKgG,0BAA0BN,IAAK7B,IAAIyB,SAGjD,GAAII,IAAIC,MAAqB,cAAbD,IAAIC,KAAsB,CACtC,IAAqBM,WAAaP,IAAIG,WAAYb,EAAGnB,IAAI,GAAIqB,EAAGrB,IAAI,KACpEA,KAAQsB,IAAKc,WAAWd,IAAKY,IAAKE,WAAWF,UAG7ClC,KAAQsB,IAAKtB,IAAI,GAAIkC,IAAKlC,IAAI,IAI1C,OAAOA,KAEXiB,kBAAkBoB,gBACdf,MAAUR,KAAMjF,KAAKyG,QACrBlB,MAAUN,KAAMjF,KAAKyG,QACrBnB,IAAQL,KAAMjF,KAAKyG,QACnBjB,IAAQP,KAAMjF,KAAKyG,QACnBX,UAAcb,KAAMjF,KAAKyG,QACzBd,MAAUV,KAAMjF,KAAKyG,SAElBrB,kBApHa,GA2HpBsB,eAAkB,SAAUC,QAE5B,SAASD,eAAeE,YACpB,IAAIpD,MAAQmD,OAAOE,KAAKvG,OAASA,KAWjC,OAVAkD,MAAMoD,WAAaA,WACnBpD,MAAMiC,IAAM,KACZjC,MAAM+B,KAAO,IACb/B,MAAMsD,KAAO,GACbtD,MAAMuD,QAAU,EAChBvD,MAAMwD,QAAU,GAChBxD,MAAMyD,cAAe,EACrBzD,MAAMwC,IAAMpB,EAAEsC,IAAIC,SAClB3D,MAAM4D,UAAY,KAClB5D,MAAM7B,mBAAqB,KACpB6B,MA2FX,OAxGA/C,UAAUiG,eAAgBC,QAkB1BD,eAAetG,UAAUiH,SAGzB,WAEI,GADAV,OAAOvG,UAAUiF,2CAA2CwB,KAAKvG,MACvC,iBAAdA,KAAQ,IAAgB,CAChC,IAAqBgH,SAAWhH,KAAK0F,IAAInD,MAAM,KAC3B,MAAhByE,SAAS,GACThH,KAAK0F,IAAMpB,EAAE0C,SAAS,IAAIA,SAAS,KAGnCC,QAAQC,KAAK,yDACblH,KAAK0F,IAAMpB,EAAEsC,IAAIC,UAGzBR,OAAOvG,UAAU2F,0BAA0Bc,KAAKvG,KAAMA,KAAK0F,KAC3D,IAAqBjE,OAAS6C,EAAErE,IAAID,KAAKmH,WAAWC,eAChD1B,IAAK1F,KAAK0F,IACV2B,YAAarH,KAAKqH,YAClBC,OAAQhD,EAAEiD,OAAOvH,KAAKmF,IAAKnF,KAAKiF,KAChCuB,KAAMxG,KAAKwG,KACXC,QAASzG,KAAKyG,QACdC,QAAS1G,KAAK0G,QACdI,UAAW9G,KAAK8G,UAChBtC,UACAgD,mBAAmB,EACnBC,oBAAoB,IAExBzH,KAAKmH,WAAWC,cAAcM,cAAgBjG,OAE9CzB,KAAKsG,WAAW9E,OAAOC,QACvBzB,KAAKsG,WAAW3E,gBAAgB3B,KAAK2G,eAKzCP,eAAetG,UAAU6H,gBAGzB,aAKAvB,eAAetG,UAAU6B,gBAGzB,WACI,GAAI3B,KAAK2G,aAAc,CACnB,IAAqBlF,OAASzB,KAAKsG,WAAW5E,SACd,OAA5B1B,KAAKqB,qBACLrB,KAAKqB,mBAAmB8C,eAAeC,UAAY,IAEvDpE,KAAKqB,mBAAqBiD,EAAEC,QAAQC,OAAOxE,KAAKsG,WAAWvD,cAAe/C,KAAKsG,WAAWtD,eAAeyB,MAAMhD,UAGvH2E,eAAe1B,aACTC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,eACVC,SAAU,iGACVC,QACI,2PAMJC,WAAYjH,gBAI5BoF,eAAevB,eAAiB,WAAc,QACxCF,KAAM3D,cAEZoF,eAAeF,gBACXf,MAAUR,KAAMjF,KAAKyG,QACrBlB,MAAUN,KAAMjF,KAAKyG,QACrBK,OAAW7B,KAAMjF,KAAKyG,QACtBM,UAAc9B,KAAMjF,KAAKyG,QACzBO,UAAc/B,KAAMjF,KAAKyG,QACzBQ,eAAmBhC,KAAMjF,KAAKyG,QAC9BT,MAAUf,KAAMjF,KAAKyG,QACrBkB,cAAkB1C,KAAMjF,KAAKyG,QAC7BW,YAAgBnC,KAAMjF,KAAKyG,QAC3BgB,aAAiBxC,KAAMjF,KAAKwI,UAAWL,MAAO,UAE3CzB,eAzGU,CA0GnBtB,mBAMEqD,yBAA4B,WAC5B,SAASA,2BACLnI,KAAKoI,WA8GT,OAvGAD,yBAAyBrI,UAAUuI,yBAKnC,SAAUC,QAAS5C,KACf,IAAIxC,MAAQlD,KAaZ,GANqB,sBAAjBsI,QAAQ3D,MACiC2D,QACvBC,SAAS5E,QAAQ,SAAU6E,SACzCtF,MAAMmF,yBAAyBG,QAAS9C,OAG3B,YAAjB4C,QAAQ3D,KAAoB,CAC5B,IAAqB6D,QAAUF,QAC/BtI,KAAKqI,yBAAyBG,QAAQC,SAAU/C,KAEpD,GAAqB,UAAjB4C,QAAQ3D,KAAkB,CAC1B,IAAqB+D,MAAQJ,QAC7BI,MAAQ1I,KAAKyF,0BAA0BiD,MAAMC,YAAajD,KAEzC,eAAjB4C,QAAQ3D,MAC0B2D,QACvBK,YAAYhF,QAAQ,SAAU+E,OACrCxF,MAAMuC,0BAA0BiD,MAAOhD,OAG1B,eAAjB4C,QAAQ3D,MAC0B2D,QACvBK,YAAYhF,QAAQ,SAAU+E,OACrCxF,MAAMuC,0BAA0BiD,MAAOhD,OAG1B,YAAjB4C,QAAQ3D,MACuB2D,QACvBK,YAAYhF,QAAQ,SAAUiF,gBAClCA,eAAejF,QAAQ,SAAU+E,OAC7BxF,MAAMuC,0BAA0BiD,MAAOhD,SAI9B,oBAAjB4C,QAAQ3D,MAC+B2D,QACvBK,YAAYhF,QAAQ,SAAUkF,YAC1CA,WAAWlF,QAAQ,SAAU+E,OACzBxF,MAAMuC,0BAA0BiD,MAAOhD,SAI9B,iBAAjB4C,QAAQ3D,MAC4B2D,QACvBK,YAAYhF,QAAQ,SAAUmF,SACvCA,QAAQnF,QAAQ,SAAUiF,gBACtBA,eAAejF,QAAQ,SAAU+E,OAC7BxF,MAAMuC,0BAA0BiD,MAAOhD,WAKlC,uBAAjB4C,QAAQ3D,MACkC2D,QACvBS,WAAWpF,QAAQ,SAAU8E,UAC5CvF,MAAMmF,yBAAyBI,SAAU/C,QASrDyC,yBAAyBrI,UAAU2F,0BAKnC,SAAUiD,MAAOhD,KAQb,GAAIA,IAAIC,MAAqB,cAAbD,IAAIC,KAAsB,CACtC,IAAqBC,UAAYF,IAAIG,WAAYb,EAAG0D,MAAM,GAAIxD,EAAGwD,MAAM,KAGvE,OAFAA,MAAM,GAAK9C,UAAUT,IACrBuD,MAAM,GAAK9C,UAAUG,IACd2C,MAGP,OAAOA,OAGfP,yBAAyBjC,gBACrBkC,UAAczD,KAAMjF,KAAKyG,SAEtBgC,yBAhHoB,GAuH3Ba,iBAAoB,WAYpB,OAXA,SAA0BC,SAGtB,GAFAjJ,KAAKkJ,OAAS,UACdlJ,KAAKmJ,SAAW,cACA,OAAZF,QACA,IAAK,IAAqBvF,OAAOuF,aACRhH,IAAjBgH,QAAQvF,OACR1D,KAAK0D,KAAOuF,QAAQvF,OAPjB,GAmBnB0F,mBAAsB,WACtB,SAASA,mBAAmB9C,WAAY+C,mBACpCrJ,KAAKsG,WAAaA,WAClBtG,KAAKoG,eAAiBiD,kBACtBrJ,KAAKsJ,QAAU,IAAIN,iBAAiB,MAgCxC,OA3BAI,mBAAmBtJ,UAAUiH,SAG7B,WACI,GAAI/G,KAAKoG,eAAgB,CACrB,IAAqB3E,OAASzB,KAAKsG,WAAW5E,SAC9C4C,EAAEC,QAAQgF,YAAYvJ,KAAKsJ,SAAS7E,MAAMhD,aAG1CwF,QAAQC,KAAK,oJAGrBkC,mBAAmB1E,aACbC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,sBACVC,SAAU,GACVC,QAAS,QAIzBoB,mBAAmBvE,eAAiB,WAAc,QAC5CF,KAAM3D,aACN2D,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,cAEtDJ,mBAAmBlD,gBACfoD,UAAc3E,KAAMjF,KAAKyG,SAEtBiD,mBApCc,GA2CrBK,WAAc,WAiBd,OAhBA,SAAoBR,SAChBjJ,KAAK0J,SAAW,IAChB1J,KAAK2J,QAAS,EACd3J,KAAK4J,UAAW,EAChB5J,KAAK6J,gBAAiB,EACtB7J,KAAKmJ,SAAW,aAChB,IAAqBW,OAASb,QACTc,KAAO/J,KAC5B,GAAe,OAAX8J,OACA,IAAK,IAAqBpG,OAAOoG,YACT7H,IAAhB6H,OAAOpG,OACPqG,KAAKrG,KAAOoG,OAAOpG,OAZtB,GAwBbsG,aAAgB,WAChB,SAASA,aAAa1D,WAAY+C,mBAC9BrJ,KAAKsG,WAAaA,WAClBtG,KAAKoG,eAAiBiD,kBACtBrJ,KAAKsJ,QAAU,IAAIG,WAAW,MAgClC,OA3BAO,aAAalK,UAAUiH,SAGvB,WACI,GAAI/G,KAAKoG,eAAgB,CACrB,IAAqB3E,OAASzB,KAAKsG,WAAW5E,SAC9C4C,EAAEC,QAAQ0F,MAAMjK,KAAKsJ,SAAS7E,MAAMhD,aAGpCwF,QAAQC,KAAK,gHAGrB8C,aAAatF,aACPC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,gBACVC,SAAU,GACVC,QAAS,QAIzBgC,aAAanF,eAAiB,WAAc,QACtCF,KAAM3D,aACN2D,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,cAEtDQ,aAAa9D,gBACToD,UAAc3E,KAAMjF,KAAKyG,SAEtB6D,aApCQ,GA2CfE,UAAa,WAiBb,OAhBA,SAAmBjB,SACfjJ,KAAKmK,WAAa,IAClBnK,KAAKoK,YAAc,UACnBpK,KAAKqK,YAAc,IACnBrK,KAAKsK,aAAe,WACpBtK,KAAKmJ,SAAW,WAChB,IAAqBW,OAASb,QACTc,KAAO/J,KAC5B,GAAe,OAAX8J,OACA,IAAK,IAAqBpG,OAAOoG,YACT7H,IAAhB6H,OAAOpG,OACPqG,KAAKrG,KAAOoG,OAAOpG,OAZvB,GAwBZ6G,YAAe,WACf,SAASA,YAAYjE,WAAY+C,mBAC7BrJ,KAAKsG,WAAaA,WAClBtG,KAAKoG,eAAiBiD,kBACtBrJ,KAAKsJ,QAAU,IAAIY,UAAU,MAgCjC,OA3BAK,YAAYzK,UAAUiH,SAGtB,WACI,GAAI/G,KAAKoG,eAAgB,CACrB,IAAqB3E,OAASzB,KAAKsG,WAAW5E,SAC9C4C,EAAEC,QAAQiC,KAAKxG,KAAKsJ,SAAS7E,MAAMhD,aAGnCwF,QAAQC,KAAK,8GAGrBqD,YAAY7F,aACNC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,eACVC,SAAU,GACVC,QAAS,QAIzBuC,YAAY1F,eAAiB,WAAc,QACrCF,KAAM3D,aACN2D,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,cAEtDe,YAAYrE,gBACRoD,UAAc3E,KAAMjF,KAAKyG,SAEtBoE,YApCO,GA2CdC,iBAAoB,WACpB,SAASA,iBAAiBlE,WAAY+C,mBAClCrJ,KAAKsG,WAAaA,WAClBtG,KAAKoG,eAAiBiD,kBAwD1B,OAnDAmB,iBAAiB1K,UAAUiH,SAG3B,WACI,IAAqB0D,KAAOzK,KAC5B,GAAIA,KAAKoG,eAAgB,CACrB,IAAqB3E,OAASzB,KAAKsG,WAAW5E,SAC1C1B,KAAK0K,MACLpG,EAAEqG,QAAmB,aACrBrG,EAAEqG,QAAmB,UAAIrG,EAAEqG,QAAQC,QAC/BC,MAAO,SAAUpJ,QACb,IAAqBqJ,QAAUxG,EAAEyG,QAAQrK,OAAO,MAAO,aAGlCsK,aAFaC,KAAKC,KAAKzJ,OAAO0J,UAAUnG,EAAIyF,KAAKW,YACpCH,KAAKC,KAAKzJ,OAAO0J,UAAUjG,EAAIuF,KAAKY,aAEtEpE,QAAQqE,IAAIN,cACZ,IAAqB1F,EAAI,EACzB,IAAKA,EAAGA,EAAI0F,aAAc1F,IAAK,CAC3B,IAAqBiG,IAAMjH,EAAEyG,QAAQrK,OAAO,MAAO,qBAAsBoK,SACzES,IAAIC,IAAMf,KAAKC,IACfa,IAAIE,MAAMC,MAAQjB,KAAKW,WAAa,KAExC,OAAON,SAEXa,SAAU,SAAUlK,YAGxB6C,EAAEC,QAAmB,UAAI,SAAUqH,MAC/B,OAAO,IAAItH,EAAEqG,QAAmB,UAAEiB,QAG1CtH,EAAEC,QAAmB,WAAI4E,SAAU,eAAgB1E,MAAMhD,UAGjE+I,iBAAiB9F,aACXC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,oBACVC,SAAU,GACVC,QAAS,QAIzBwC,iBAAiB3F,eAAiB,WAAc,QAC1CF,KAAM3D,aACN2D,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,cAEtDgB,iBAAiBtE,gBACbwE,MAAU/F,KAAMjF,KAAKyG,QACrBiF,aAAiBzG,KAAMjF,KAAKyG,QAC5BkF,cAAkB1G,KAAMjF,KAAKyG,SAE1BqE,iBA3DY,GAkEnBqB,aAAgB,WAChB,SAASA,aAAavF,YAClBtG,KAAKsG,WAAaA,WAClBtG,KAAK8L,YAAc,GACnB9L,KAAK+L,SAAW,GAChB/L,KAAKgC,KAAO,GACZhC,KAAKgM,QAAU,EACfhM,KAAK2E,KAAO,UACZ3E,KAAKuJ,YAAc,KAqDvB,OAhDAsC,aAAa/L,UAAUiH,SAGvB,WACI/G,KAAKsG,WAAWvC,iBAChB,IAAqBtC,OAASzB,KAAKsG,WAAW5E,SACzBuK,MAAQ,KACJ,KAArBjM,KAAK8L,cACLG,MAAQ3H,EAAE4H,UAAUlM,KAAK8L,aACrBvC,YAAavJ,KAAKuJ,eAGJ,KAAlBvJ,KAAK+L,UAAiC,KAAd/L,KAAKgC,OAC7BiK,MAAQ3H,EAAE4H,UAAUC,IAAInM,KAAK+L,UACzBvH,OAAQxE,KAAKgC,KACbuH,YAAavJ,KAAKuJ,cACnB6C,WAAWpM,KAAKgM,UAEnBC,aACkB,YAAdjM,KAAK2E,MACL3E,KAAKsG,WAAW9D,WAAWyJ,MAAOjM,KAAKgC,MACvCiK,MAAMxH,MAAMhD,SAEO,YAAdzB,KAAK2E,OACV3E,KAAKsG,WAAWxE,WAAWmK,MAAOjM,KAAKgC,MACvCiK,MAAMxH,MAAMhD,WAIxBoK,aAAanH,aACPC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,gBACVC,SAAU,GACVC,QAAS,QAIzB6D,aAAahH,eAAiB,WAAc,QACtCF,KAAM3D,cAEZ6K,aAAa3F,gBACT4F,cAAkBnH,KAAMjF,KAAKyG,QAC7B4F,WAAepH,KAAMjF,KAAKyG,QAC1BnE,OAAW2C,KAAMjF,KAAKyG,QACtB6F,UAAcrH,KAAMjF,KAAKyG,QACzBxB,OAAWA,KAAMjF,KAAKyG,QACtBoD,cAAkB5E,KAAMjF,KAAKyG,SAE1B0F,aA7DQ,GAoEfQ,oBAAuB,SAAUhG,QAEjC,SAASgG,oBAAoB/F,WAAY+C,mBACrC,IAAInG,MAAQmD,OAAOE,KAAKvG,OAASA,KAQjC,OAPAkD,MAAMoD,WAAaA,WACnBpD,MAAMkD,eAAiBiD,kBACvBnG,MAAMoJ,UAAY,MAAO,KAAM,OAAQ,OACvCpJ,MAAMqJ,UAAY,GAClBrJ,MAAMlB,KAAO,GACbkB,MAAM8I,QAAU,EAChB9I,MAAMyB,KAAO,UACNzB,MA6CX,OAvDA/C,UAAUkM,oBAAqBhG,QAe/BgG,oBAAoBvM,UAAUiH,SAG9B,WAEI,GADA/G,KAAKwF,QAAUxF,KAAKsM,OAChBtM,KAAKoG,eAAgB,CACrB,IAAqB3E,OAASzB,KAAKsG,WAAW5E,SAC9C2E,OAAOvG,UAAUkG,0BAA0BO,KAAKvG,KAAMA,KAAKoG,eAAeV,KAC1E,IAAqBuG,MAAQ,MAC7BA,MAAQ3H,EAAEkI,aAAaxM,KAAKuM,UAAWvM,KAAKsM,QAAQF,WAAWpM,KAAKgM,iBAE9C,YAAdhM,KAAK2E,MACL3E,KAAKsG,WAAW9D,WAAWyJ,MAAOjM,KAAKgC,MACvCiK,MAAMxH,MAAMhD,SAEO,YAAdzB,KAAK2E,MACV3E,KAAKsG,WAAWxE,WAAWmK,MAAOjM,KAAKgC,SAKvDqK,oBAAoB3H,aACdC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,wBACVC,SAAU,GACVC,QAAS,QAIzBqE,oBAAoBxH,eAAiB,WAAc,QAC7CF,KAAM3D,aACN2D,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,cAEtD6C,oBAAoBnG,gBAChBoG,SAAa3H,KAAMjF,KAAKyG,QACxBoG,YAAgB5H,KAAMjF,KAAKyG,QAC3BnE,OAAW2C,KAAMjF,KAAKyG,QACtB6F,UAAcrH,KAAMjF,KAAKyG,QACzBxB,OAAWA,KAAMjF,KAAKyG,SAEnBkG,oBAxDe,CAyDxBvH,mBAME2H,YAAe,WACf,SAASA,eAmBT,OAdAA,YAAY3M,UAAU4M,QAGtB,WACI,MAAO,uCAAuCC,QAAQ,QAAS,SAAUC,GACrE,IAAqBC,EAAoB,GAAhB5B,KAAK6B,SAAgB,EAC9C,OAD2E,KAALF,EAAWC,EAAS,EAAJA,EAAU,GACvFE,SAAS,OAG1BN,YAAY/H,aACNC,KAAMjF,KAAKkF,aAGjB6H,YAAY5H,eAAiB,WAAc,UACpC4H,YApBO,GA2BdO,aAAgB,WAChB,SAASA,aAAaC,aAClBjN,KAAKiN,YAAcA,YACnBjN,KAAKkN,cACLlN,KAAKmN,WACLnN,KAAKoN,iBAAmB,EACxBpN,KAAKqN,SAoGT,OAzFAL,aAAalN,UAAUwN,kBASvB,SAAU7K,QAAShB,OAAQ6E,WAAY+G,MAAOV,QAASjK,UACnC,IAAZiK,UAAsBA,SAAU,GAC/BjK,MACDA,IAAM1C,KAAKiN,YAAYP,YAEQ,IAA/B1M,KAAKmN,QAAQ9K,QAAQK,MACrB1C,KAAKmN,QAAQtK,KAAKH,KAEiB,IAAnCjC,OAAOwD,KAAKjE,KAAKqN,OAAOnJ,SACpByI,SACAlL,OAAO8L,YAAYvN,KAAKqN,QACW,IAA/BrN,KAAKmN,QAAQ9K,QAAQK,KACrB1C,KAAKkN,WAAWlN,KAAKmN,QAAQ9K,QAAQK,MAAQD,QAG7CzC,KAAKkN,WAAWrK,KAAKJ,SAEzBzC,KAAKqN,MAAQ/I,EAAE4I,WAAWlN,KAAKwN,iBAC/BxN,KAAKqN,MAAM5I,MAAMhD,UAGjBzB,KAAKkN,WAAWrK,KAAKJ,SACrBzC,KAAKqN,MAAMI,SAAShL,WAGvBkK,UACD3M,KAAKkN,WAAWrK,KAAKJ,SACrBzC,KAAKqN,MAAQ/I,EAAE4I,WAAWlN,KAAKwN,iBAC/BxN,KAAKqN,MAAM5I,MAAMhD,SAErB6E,WAAW9D,WAAWxC,KAAK0N,WAAYL,MAAMrL,KAAMqL,MAAMM,WAK7DX,aAAalN,UAAU8N,mBAGvB,WACI,IAAI1K,MAAQlD,KACZ,OAAOH,WAAWA,WAAWa,OAAO,SAAUyC,UAC1C,IAAqBkK,MAAQnK,MAAMwK,WACnCvK,SAASC,KAAKiK,OACdlK,SAASE,cAMjB2J,aAAalN,UAAU4N,SAGvB,WACI,OAAO1N,KAAKqN,OAKhBL,aAAalN,UAAU0N,cAGvB,WACI,OAAOxN,KAAKkN,YAKhBF,aAAalN,UAAUkE,eAGvB,WACI,OAAOhE,KAAKoN,kBAEhBJ,aAAatI,aACPC,KAAMjF,KAAKkF,aAGjBoI,aAAanI,eAAiB,WAAc,QACtCF,KAAM8H,eAELO,aA1GQ,GAiHfa,aAAgB,WAChB,SAASA,gBA6DT,OApDAA,aAAa/N,UAAUgO,YAOvB,SAAUC,UAAWC,QAASpK,QAASqK,MAC/BF,WAAaC,UACbD,eAAY9L,EACZgF,QAAQC,KAAK,+FAEb6G,YACkB,SAAdA,WAAwBE,KACxBF,UAAYE,MAEO,IAAdF,WAAuBE,OAC5BF,UAAY,QAEhBnK,QAAQsK,UAAUH,WAClBnK,QAAQuK,GAAG,YAAa,WACpBnO,KAAKoO,cACND,GAAG,WAAY,WACdnO,KAAKqO,gBAGTL,UACgB,SAAZA,SAAsBC,KACtBD,QAAUC,MAEO,IAAZD,SAAqBC,OAC1BD,QAAU,QAEdpK,QAAQsK,UAAUF,SAClBpK,QAAQuK,GAAG,QAAS,WAChBnO,KAAKoO,eAGRL,WAAcC,UAAWC,OAC1BrK,QAAQsK,UAAUD,MAClBrK,QAAQuK,GAAG,YAAa,WACpBnO,KAAKoO,cACND,GAAG,WAAY,WACdnO,KAAKqO,iBAIjBR,aAAanJ,aACPC,KAAMjF,KAAKkF,aAGjBiJ,aAAahJ,eAAiB,WAAc,UACrCgJ,aA9DQ,GAqEfS,aAAgB,WAChB,SAASA,aAAahI,WAAYiI,aAActB,aAC5CjN,KAAKsG,WAAaA,WAClBtG,KAAKuO,aAAeA,aACpBvO,KAAKiN,YAAcA,YACnBjN,KAAKgC,KAAO,GACZhC,KAAK2N,SAAW3N,KAAKiN,YAAYP,UAmCrC,OA9BA4B,aAAaxO,UAAUiH,SAGvB,aAKAuH,aAAaxO,UAAU6H,gBAGvB,aAEA2G,aAAa5J,aACPC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,gBACVC,SAAU,GACVC,QAAS,IACTC,WAAY+E,kBAI5BsB,aAAazJ,eAAiB,WAAc,QACtCF,KAAM3D,aACN2D,KAAMqI,eACNrI,KAAM8H,eAEZ6B,aAAapI,gBACTlE,OAAW2C,KAAMjF,KAAKyG,SAEnBmI,aAzCQ,GAgDfE,cAAiB,SAAUnI,QAE3B,SAASmI,cAAclI,WAAYmI,aAAcC,QAASH,aAAclF,kBAAmBsF,iBACvF,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAajC,OAZAkD,MAAMoD,WAAaA,WACnBpD,MAAMuL,aAAeA,aACrBvL,MAAMtD,KAAO8O,QACbxL,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMiC,IAAM,KACZjC,MAAM+B,KAAO,IACb/B,MAAM6K,eAAY9L,EAClBiB,MAAM8K,aAAU/L,EAChBiB,MAAM0L,QAAU,GAChB1L,MAAM2L,OAAS,KACR3L,MAoIX,OAnJA/C,UAAUqO,cAAenI,QAoBzBmI,cAAc1O,UAAUiH,SAGxB,WACIV,OAAOvG,UAAUiF,2CAA2CwB,KAAKvG,MACjE,IAAqB8O,MAAQ9O,KAC7B,GAAIA,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAC1C,IAAqBS,MAAQ/O,KAAKsG,WAAW5E,SAC7C2E,OAAOvG,UAAU2F,0BAA0Bc,KAAKvG,KAAMA,KAAKoG,eAAeV,KACrD,KAAjB1F,KAAK4O,SACL5O,KAAK6O,OAASvK,EAAEuK,QAAQ7O,KAAKmF,IAAKnF,KAAKiF,MACvCjF,KAAKgP,kBAAkBhP,KAAK6O,OAAQE,QAGpC/O,KAAKiP,YAAYjP,KAAK4O,QAAS,SAAUM,QACrCJ,MAAMK,WAAWC,UAAU,SAAUC,OACjC,IAAqB9D,IAAM+D,SAASC,cAAc,OAClDC,OAAOC,IAAIC,gBAAgBL,MAAMM,QACjC,IAAqBC,OAAS,IAAIC,WAClCD,OAAOE,OAAS,WACZvE,IAAIC,IAAMoE,OAAOG,OACjB,IAMqBC,KAAQC,KANC3L,EAAE2L,MAC5BrB,QAASE,MAAMF,QACfsB,UAAW3E,IAAIG,MAAOH,IAAI4E,QAC1BC,YAAa7E,IAAIG,MAAQ,EAAGH,IAAI4E,OAAS,GACzCE,aAAc,GAAI9E,IAAI4E,UAEiBlH,QAAS,MACpD6F,MAAMD,OAASvK,EAAEuK,QAAQC,MAAM3J,IAAK2J,MAAM7J,KAAM+K,KAChDlB,MAAME,kBAAkBF,MAAMD,OAAQE,QAE1Ca,OAAOU,cAAcjB,MAAMM,SAC5B,SAAUY,KACTtJ,QAAQqE,IAAIiF,cAMxBtJ,QAAQC,KAAK,0IAQrBsH,cAAc1O,UAAUkP,kBAKxB,SAAUH,OAAQpN,QACd,IAAqB+O,eAAYvO,EAC7BjC,KAAKyQ,KAAKrJ,cAAcsJ,WAAWxM,OAAS,IAE5CsM,UADgCxQ,KAAKyQ,KAAKrJ,cAAcsJ,WAAW,GAC9CC,gBAGF1O,IAAnBjC,KAAK+N,gBAA4C9L,IAAjBjC,KAAKgO,cAAuC/L,IAAduO,WAC9DxQ,KAAKyO,aAAaX,YAAY9N,KAAK+N,UAAW/N,KAAKgO,QAAShO,KAAK6O,OAAQ2B,WAGzExQ,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkBuB,OAAQpN,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAG1EO,OAAOpK,MAAMhD,SAQrB+M,cAAc1O,UAAUmP,YAKxB,SAAUvE,IAAKkG,UACX,IAAqBrF,IAAM,IAAIsF,MAC/BtF,IAAIuE,OAAS,WAAcc,UAAS,IACpCrF,IAAIuF,QAAU,WAAcF,UAAS,IACrCrF,IAAIC,IAAMd,KAKd8D,cAAc1O,UAAUqP,SAGxB,WACI,IAAqB4B,QAAU,IAAInR,KAAKoR,SAAUC,eAAgB,sCAC7ChI,QAAU,IAAIrJ,KAAKsR,gBACpCC,aAAcvR,KAAKwR,oBAAoBC,KACvCN,QAASA,UAEb,OAAO/Q,KAAKJ,KAAK0R,IAAItR,KAAK4O,QAAS3F,SAC9BhJ,IAAI,SAAUsR,KAAO,OAAOA,MAC5BC,MAAM,SAAUC,OAAS,OAAO5R,WAAWA,WAAW6R,MAAM,mBAErElD,cAAc9J,aACRC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,iBACVC,SAAU,6CACVC,QAAS,IACTC,WAAY4F,kBAI5BW,cAAc3J,eAAiB,WAAc,QACvCF,KAAM3D,aACN2D,KAAMkJ,eACNlJ,KAAM/E,KAAK+R,OACXhN,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAEpDgF,cAActI,gBACVf,MAAUR,KAAMjF,KAAKyG,QACrBlB,MAAUN,KAAMjF,KAAKyG,QACrB4H,YAAgBpJ,KAAMjF,KAAKyG,QAC3B6H,UAAcrJ,KAAMjF,KAAKyG,QACzByI,UAAcjK,KAAMjF,KAAKyG,QACzBsK,OAAW9L,KAAMjF,KAAKwI,UAAWL,MAAO,WAErC2G,cApJS,CAqJlB1J,mBAME8M,KAAQ,WA0BR,OAzBA,SAAcC,UACV7R,KAAK8R,QAAS,EACd9R,KAAK+R,MAAQ,UACb/R,KAAKgS,OAAS,EACdhS,KAAKgM,QAAU,EACfhM,KAAKiS,QAAU,QACfjS,KAAKkS,SAAW,QAChBlS,KAAKmS,UAAY,KACjBnS,KAAKoS,WAAa,KAClBpS,KAAKqS,MAAO,EACZrS,KAAKsS,UAAY,UACjBtS,KAAKuS,YAAc,GACnBvS,KAAKwS,SAAW,UAEhBxS,KAAKyS,UAAY,KACjB,IAAqB3I,OAAS+H,SACT9H,KAAO/J,KAC5B,GAAe,OAAX8J,OACA,IAAK,IAAqBpG,OAAOoG,YACT7H,IAAhB6H,OAAOpG,OACPqG,KAAKrG,KAAOoG,OAAOpG,OArB5B,GAiCPgP,cAAiB,SAAUrM,QAE3B,SAASqM,cAAcpM,WAAYmI,aAAcF,aAAclF,kBAAmBsF,iBAC9E,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAajC,OAZAkD,MAAMoD,WAAaA,WACnBpD,MAAMuL,aAAeA,aACrBvL,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMiC,IAAM,KACZjC,MAAM+B,KAAO,IACb/B,MAAMyP,OAAS,GACfzP,MAAM6K,eAAY9L,EAClBiB,MAAM8K,aAAU/L,EAChBiB,MAAMoG,QAAU,IAAIsI,KAAK,MACzB1O,MAAM0P,OAAS,KACR1P,MAsEX,OArFA/C,UAAUuS,cAAerM,QAoBzBqM,cAAc5S,UAAUiH,SAGxB,WAGI,GAFAV,OAAOvG,UAAUiF,2CAA2CwB,KAAKvG,MAE7DA,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAC1C,IAAqBuE,iBAAmB,IAAIjB,KAAK5R,KAAKsJ,SACjC7H,OAASzB,KAAKsG,WAAW5E,SAC9C2E,OAAOvG,UAAU2F,0BAA0Bc,KAAKvG,KAAMA,KAAKoG,eAAeV,KAC1E1F,KAAK4S,OAAStO,EAAEsO,QAAQ5S,KAAKmF,IAAKnF,KAAKiF,KAAMjF,KAAK2S,OAAQE,kBACtD7S,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkBtN,KAAK4S,OAAQnR,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAG/EtO,KAAK4S,OAAOnO,MAAMhD,aAItBwF,QAAQC,KAAK,0IAMrBwL,cAAc5S,UAAU6H,gBAGxB,WACI,GAAI3H,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAC1C,IAAqBkC,eAAYvO,EAC7BjC,KAAKyQ,KAAKrJ,cAAcsJ,WAAWxM,OAAS,IAE5CsM,UADgCxQ,KAAKyQ,KAAKrJ,cAAcsJ,WAAW,GAC9CC,gBAGF1O,IAAnBjC,KAAK+N,gBAA4C9L,IAAjBjC,KAAKgO,cAAuC/L,IAAduO,WAC9DxQ,KAAKyO,aAAaX,YAAY9N,KAAK+N,UAAW/N,KAAKgO,QAAShO,KAAK4S,OAAQpC,aAIrFkC,cAAchO,aACRC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,iBACVC,SAAU,6CACVC,QAAS,QAIzB0K,cAAc7N,eAAiB,WAAc,QACvCF,KAAM3D,aACN2D,KAAMkJ,eACNlJ,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAEpDkJ,cAAcxM,gBACVf,MAAUR,KAAMjF,KAAKyG,QACrBlB,MAAUN,KAAMjF,KAAKyG,QACrBwM,SAAahO,KAAMjF,KAAKyG,QACxB4H,YAAgBpJ,KAAMjF,KAAKyG,QAC3B6H,UAAcrJ,KAAMjF,KAAKyG,QACzBmD,UAAc3E,KAAMjF,KAAKyG,QACzBsK,OAAW9L,KAAMjF,KAAKwI,UAAWL,MAAO,WAErC6K,cAtFS,CAuFlB5N,mBAMEgO,oBAAuB,SAAUzM,QAEjC,SAASyM,oBAAoBxM,WAAYmI,aAAcF,aAAclF,kBAAmBsF,iBACpF,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAYjC,OAXAkD,MAAMoD,WAAaA,WACnBpD,MAAMuL,aAAeA,aACrBvL,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMiC,IAAM,KACZjC,MAAM+B,KAAO,IACb/B,MAAM6K,eAAY9L,EAClBiB,MAAM8K,aAAU/L,EAChBiB,MAAMoG,QAAU,IAAIsI,KAAK,MACzB1O,MAAM0P,OAAS,KACR1P,MAmEX,OAjFA/C,UAAU2S,oBAAqBzM,QAmB/ByM,oBAAoBhT,UAAUiH,SAG9B,WAGI,GAFAV,OAAOvG,UAAUiF,2CAA2CwB,KAAKvG,MAE7DA,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAC1C,IAAqBuE,iBAAmB,IAAIjB,KAAK5R,KAAKsJ,SACjC7H,OAASzB,KAAKsG,WAAW5E,SACP2E,OAAOvG,UAAU2F,0BAA0Bc,KAAKvG,KAAMA,KAAKoG,eAAeV,KACjH1F,KAAK4S,OAAStO,EAAEyO,cAAc/S,KAAKmF,IAAKnF,KAAKiF,KAAM4N,kBAC/C7S,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkBtN,KAAK4S,OAAQnR,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAG/EtO,KAAK4S,OAAOnO,MAAMhD,aAItBwF,QAAQC,KAAK,0IAMrB4L,oBAAoBhT,UAAU6H,gBAG9B,WACI,IAAqB6I,eAAYvO,EAC7BjC,KAAKyQ,KAAKrJ,cAAcsJ,WAAWxM,OAAS,IAE5CsM,UADgCxQ,KAAKyQ,KAAKrJ,cAAcsJ,WAAW,GAC9CC,gBAGF1O,IAAnBjC,KAAK+N,gBAA4C9L,IAAjBjC,KAAKgO,cAAuC/L,IAAduO,WAC9DxQ,KAAKyO,aAAaX,YAAY9N,KAAK+N,UAAW/N,KAAKgO,QAAShO,KAAK4S,OAAQpC,YAGjFsC,oBAAoBpO,aACdC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,wBACVC,SAAU,6CACVC,QAAS,QAIzB8K,oBAAoBjO,eAAiB,WAAc,QAC7CF,KAAM3D,aACN2D,KAAMkJ,eACNlJ,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAEpDsJ,oBAAoB5M,gBAChBf,MAAUR,KAAMjF,KAAKyG,QACrBlB,MAAUN,KAAMjF,KAAKyG,QACrB4H,YAAgBpJ,KAAMjF,KAAKyG,QAC3B6H,UAAcrJ,KAAMjF,KAAKyG,QACzBmD,UAAc3E,KAAMjF,KAAKyG,QACzBsK,OAAW9L,KAAMjF,KAAKwI,UAAWL,MAAO,WAErCiL,oBAlFe,CAmFxBhO,mBAMEkO,cAAiB,WACjB,SAASA,iBAkCT,OA3BAA,cAAclT,UAAUmT,aAKxB,SAAUC,EAAG7S,GACT,GAAI6S,EAAEhP,QAAU7D,EAAE6D,OACd,OAAO,EAEX,IAAK,IAAqBoB,KAAK4N,EAE3B,GAAIA,EAAE5N,aAAczE,OAASR,EAAEiF,aAAczE,OACzC,IAAKb,KAAKiT,aAAaC,EAAE5N,GAAIjF,EAAEiF,IAC3B,OAAO,OAGV,GAAI4N,EAAE5N,IAAMjF,EAAEiF,GACf,OAAO,EAGf,OAAO,GAEX0N,cAActO,aACRC,KAAMjF,KAAKkF,aAGjBoO,cAAcnO,eAAiB,WAAc,UACtCmO,cAnCS,GA0ChBG,eAAkB,SAAU9M,QAE5B,SAAS8M,eAAe7M,WAAYmI,aAAcxB,YAAamG,cAAe7E,aAAclF,kBAAmBsF,iBAC3G,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAgBjC,OAfAkD,MAAMoD,WAAaA,WACnBpD,MAAMuL,aAAeA,aACrBvL,MAAM+J,YAAcA,YACpB/J,MAAMkQ,cAAgBA,cACtBlQ,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMsC,WAAa,OAAQ,MAAO,QAAS,OAAQ,QAAS,QAAS,QAAS,UACxE,OAAQ,OAAQ,QAAS,OAAQ,QAAS,QAAS,QAAS,SAClEtC,MAAMoG,QAAU,IAAIsI,KAAK,MACzB1O,MAAM6K,eAAY9L,EAClBiB,MAAM8K,aAAU/L,EAChBiB,MAAM4F,QAAU,KAChB5F,MAAMmQ,eAAiBnQ,MAAMsC,QAAQ8N,QACrCpQ,MAAMyK,SAAWzK,MAAM+J,YAAYP,UAC5BxJ,MA4FX,OA9GA/C,UAAUgT,eAAgB9M,QAuB1B8M,eAAerT,UAAUiH,SAGzB,WAGI,GAFAV,OAAOvG,UAAUsF,2CAA2CmB,KAAKvG,MAE7DA,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAC1C,IAAqBuE,iBAAmB,IAAIjB,KAAK5R,KAAKsJ,SACjC7H,OAASzB,KAAKsG,WAAW5E,SAC9C2E,OAAOvG,UAAUkG,0BAA0BO,KAAKvG,KAAMA,KAAKoG,eAAeV,KAC1E1F,KAAK8I,QAAUxE,EAAEwE,SAAS9I,KAAKwF,SAAUqN,kBACrC7S,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkBtN,KAAK8I,QAASrH,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAAc,EAAOtO,KAAK2N,UAG1G3N,KAAK8I,QAAQrE,MAAMhD,aAIvBwF,QAAQC,KAAK,4IAMrBiM,eAAerT,UAAU6H,gBAGzB,WACI,IAAqB6I,eAAYvO,EAC7BjC,KAAKyQ,KAAKrJ,cAAcsJ,WAAWxM,OAAS,IAE5CsM,UADgCxQ,KAAKyQ,KAAKrJ,cAAcsJ,WAAW,GAC9CC,gBAGF1O,IAAnBjC,KAAK+N,gBAA4C9L,IAAjBjC,KAAKgO,cAAuC/L,IAAduO,WAC9DxQ,KAAKyO,aAAaX,YAAY9N,KAAK+N,UAAW/N,KAAKgO,QAAShO,KAAK8I,QAAS0H,YAMlF2C,eAAerT,UAAUyT,UAGzB,WACI,IAAqB9R,OAASzB,KAAKsG,WAAW5E,SAE9C,IAD4B1B,KAAKoT,cAAcH,aAAajT,KAAKqT,eAAgBrT,KAAKwF,SAC3E,CACPxF,KAAKqT,eAAiBrT,KAAKwF,QAAQ8N,QAEnC,IAAqBT,iBAAmB,IAAIjB,KAAK5R,KAAKsJ,SAClDtJ,KAAKsO,cACLtO,KAAK8I,QAAUxE,EAAEwE,SAAS9I,KAAKwF,SAAUqN,kBACzC7S,KAAKuO,aAAajB,kBAAkBtN,KAAK8I,QAASrH,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAAc,EAAMtO,KAAK2N,YAGzGlM,OAAO8L,YAAYvN,KAAK8I,SACxB9I,KAAK8I,QAAUxE,EAAEwE,SAAS9I,KAAKwF,SAAUqN,kBACzC7S,KAAK8I,QAAQrE,MAAMhD,WAI/B0R,eAAezO,aACTC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,kBACVC,SAAU,6CACVC,QAAS,QAIzBmL,eAAetO,eAAiB,WAAc,QACxCF,KAAM3D,aACN2D,KAAMkJ,eACNlJ,KAAM8H,cACN9H,KAAMqO,gBACNrO,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAEpD2J,eAAejN,gBACXV,UAAcb,KAAMjF,KAAKyG,QACzBmD,UAAc3E,KAAMjF,KAAKyG,QACzB4H,YAAgBpJ,KAAMjF,KAAKyG,QAC3B6H,UAAcrJ,KAAMjF,KAAKyG,QACzBsK,OAAW9L,KAAMjF,KAAKwI,UAAWL,MAAO,WAErCsL,eA/GU,CAgHnBrO,mBAME0O,gBAAmB,SAAUnN,QAE7B,SAASmN,gBAAgBlN,WAAYmI,aAAcxB,YAAamG,cAAe7E,aAAclF,kBAAmBsF,iBAC5G,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAejC,OAdAkD,MAAMoD,WAAaA,WACnBpD,MAAMuL,aAAeA,aACrBvL,MAAM+J,YAAcA,YACpB/J,MAAMkQ,cAAgBA,cACtBlQ,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMsC,UAAY,MAAO,MAAO,QAAS,MAAO,QAAS,QAAS,QAAS,QAC3EtC,MAAMoG,QAAU,IAAIsI,KAAK,MACzB1O,MAAM6K,eAAY9L,EAClBiB,MAAM8K,aAAU/L,EAChBiB,MAAMuQ,SAAW,KACjBvQ,MAAMmQ,eAAiBnQ,MAAMsC,QAAQ8N,QACrCpQ,MAAMyK,SAAWzK,MAAM+J,YAAYP,UAC5BxJ,MA+FX,OAhHA/C,UAAUqT,gBAAiBnN,QAsB3BmN,gBAAgB1T,UAAUiH,SAG1B,WAGI,GAFAV,OAAOvG,UAAUsF,2CAA2CmB,KAAKvG,MAE7DA,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAE1CtO,KAAKsJ,QAAQ+I,MAAO,EACpB,IAAqBQ,iBAAmB,IAAIjB,KAAK5R,KAAKsJ,SACjC7H,OAASzB,KAAKsG,WAAW5E,SAC9C2E,OAAOvG,UAAUkG,0BAA0BO,KAAKvG,KAAMA,KAAKoG,eAAeV,KAC1E1F,KAAKyT,SAAWnP,EAAEmP,SAASzT,KAAKwF,QAASqN,kBACrC7S,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkBtN,KAAKyT,SAAUhS,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAAc,EAAOtO,KAAK2N,UAG3G3N,KAAKyT,SAAShP,MAAMhD,aAIxBwF,QAAQC,KAAK,8IAMrBsM,gBAAgB1T,UAAU6H,gBAG1B,WACI,IAAqB6I,eAAYvO,EAC7BjC,KAAKyQ,KAAKrJ,cAAcsJ,WAAWxM,OAAS,IAE5CsM,UADgCxQ,KAAKyQ,KAAKrJ,cAAcsJ,WAAW,GAC9CC,gBAGF1O,IAAnBjC,KAAK+N,gBAA4C9L,IAAjBjC,KAAKgO,cAAuC/L,IAAduO,WAC9DxQ,KAAKyO,aAAaX,YAAY9N,KAAK+N,UAAW/N,KAAKgO,QAAShO,KAAKyT,SAAUjD,YAMnFgD,gBAAgB1T,UAAUyT,UAG1B,WACI,IAAqB9R,OAASzB,KAAKsG,WAAW5E,SAE9C,IAD4B1B,KAAKoT,cAAcH,aAAajT,KAAKqT,eAAgBrT,KAAKwF,SAC3E,CACPxF,KAAKqT,eAAiBrT,KAAKwF,QAAQ8N,QAEnCtT,KAAKsJ,QAAQ+I,MAAO,EACpB,IAAqBQ,iBAAmB,IAAIjB,KAAK5R,KAAKsJ,SAClDtJ,KAAKsO,cACLtO,KAAKyT,SAAWnP,EAAEmP,SAASzT,KAAKwF,QAASqN,kBACzC7S,KAAKuO,aAAajB,kBAAkBtN,KAAKyT,SAAUhS,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAAc,EAAMtO,KAAK2N,YAG1GlM,OAAO8L,YAAYvN,KAAKyT,UACxBzT,KAAKyT,SAAWnP,EAAEmP,SAASzT,KAAKwF,QAASqN,kBACzC7S,KAAKyT,SAAShP,MAAMhD,WAIhC+R,gBAAgB9O,aACVC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,mBACVC,SAAU,6CACVC,QAAS,QAIzBwL,gBAAgB3O,eAAiB,WAAc,QACzCF,KAAM3D,aACN2D,KAAMkJ,eACNlJ,KAAM8H,cACN9H,KAAMqO,gBACNrO,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAEpDgK,gBAAgBtN,gBACZV,UAAcb,KAAMjF,KAAKyG,QACzBmD,UAAc3E,KAAMjF,KAAKyG,QACzB4H,YAAgBpJ,KAAMjF,KAAKyG,QAC3B6H,UAAcrJ,KAAMjF,KAAKyG,QACzBsK,OAAW9L,KAAMjF,KAAKwI,UAAWL,MAAO,WAErC2L,gBAjHW,CAkHpB1O,mBAME4O,eAAkB,SAAUrN,QAE5B,SAASqN,eAAepN,WAAYmI,aAAcxB,YAAamG,cAAe7E,aAAclF,kBAAmBsF,iBAC3G,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAUjC,OATAkD,MAAMoD,WAAaA,WACnBpD,MAAMuL,aAAeA,aACrBvL,MAAM+J,YAAcA,YACpB/J,MAAMkQ,cAAgBA,cACtBlQ,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMmQ,eAAiB5S,OAAOkT,UAAWzQ,MAAMkF,SAC/ClF,MAAMyK,SAAWzK,MAAM+J,YAAYP,UAC5BxJ,MAyDX,OArEA/C,UAAUuT,eAAgBrN,QAiB1BqN,eAAe5T,UAAUiH,SAGzB,WAEI,GAAI/G,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAE1C,IAAqB7M,OAASzB,KAAKsG,WAAW5E,SAC9C,GAAI1B,KAAKoI,QAAS,CACd/B,OAAOvG,UAAUuI,yBAAyB9B,KAAKvG,KAAMA,KAAKoI,QAASpI,KAAKoG,eAAeV,KACvF,IAAqBkO,MAAQtP,EAAEgE,QAAQtI,KAAKoI,SACxCpI,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkBsG,MAAOnS,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAAc,EAAOtO,KAAK2N,UAGnGiG,MAAMnP,MAAMhD,aAIhBwF,QAAQC,KAAK,6CAIjBD,QAAQC,KAAK,8IAMrBwM,eAAe5T,UAAUyT,UAGzB,WACkCvT,KAAKsG,WAAW5E,UAElDgS,eAAehP,aACTC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,kBACVC,SAAU,GACVC,QAAS,QAIzB0L,eAAe7O,eAAiB,WAAc,QACxCF,KAAM3D,aACN2D,KAAMkJ,eACNlJ,KAAM8H,cACN9H,KAAMqO,gBACNrO,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAE7CkK,eAtEU,CAuEnBvL,0BAME0L,aAAgB,SAAUxN,QAE1B,SAASwN,aAAavN,WAAYiI,aAAclF,kBAAmBsF,iBAC/D,IAAIzL,MAAQmD,OAAOE,KAAKvG,OAASA,KAQjC,OAPAkD,MAAMoD,WAAaA,WACnBpD,MAAMqL,aAAeA,aACrBrL,MAAMkD,eAAiBiD,kBACvBnG,MAAMoL,aAAeK,gBACrBzL,MAAMiC,IAAM,KACZjC,MAAM+B,KAAO,IACb/B,MAAM4Q,QAAU,aACT5Q,MA6CX,OAvDA/C,UAAU0T,aAAcxN,QAexBwN,aAAa/T,UAAUiH,SAGvB,WAGI,GAFAV,OAAOvG,UAAUiF,2CAA2CwB,KAAKvG,MAE7DA,KAAKoG,gBAAkBpG,KAAKsO,aAAc,CAC1C,IAAqB7M,OAASzB,KAAKsG,WAAW5E,SAC9C2E,OAAOvG,UAAU2F,0BAA0Bc,KAAKvG,KAAMA,KAAKoG,eAAeV,KAC1E,IAAqBqO,MAAQzP,EAAEyP,OAAQC,WAAW,EAAOC,YAAY,IAAQC,WAAWlU,KAAKmF,IAAKnF,KAAKiF,MAAMkP,WAA6BnU,KAAY,SAClJA,KAAKsO,aACLtO,KAAKuO,aAAajB,kBAAkByG,MAAOtS,OAAQzB,KAAKsG,WAAYtG,KAAKsO,cAGzEyF,MAAMtP,MAAMhD,aAIhBwF,QAAQC,KAAK,wIAGrB2M,aAAanP,aACPC,KAAMjF,KAAKkI,UAAWC,OACZC,SAAU,gBACVC,SAAU,GACVC,QAAS,QAIzB6L,aAAahP,eAAiB,WAAc,QACtCF,KAAM3D,aACN2D,KAAMqI,aAActI,aAAeC,KAAMjF,KAAK8J,aAC9C7E,KAAMyB,eAAgB1B,aAAeC,KAAMjF,KAAK8J,aAChD7E,KAAM2J,aAAc5J,aAAeC,KAAMjF,KAAK8J,cAEpDqK,aAAa3N,gBACTf,MAAUR,KAAMjF,KAAKyG,QACrBlB,MAAUN,KAAMjF,KAAKyG,QACrB2N,UAAcnP,KAAMjF,KAAKyG,SAEtB0N,aAxDQ,CAyDjB/O,mBAMEsP,iBAAoB,WACpB,SAASA,oBAmDT,OAjDAA,iBAAiB1P,aACXC,KAAMjF,KAAK2U,SAAUxM,OACXyM,SACIvU,OAAOwU,aACP3U,KAAK4U,YAETC,cACIrO,eACAgD,mBACAY,aACAO,YACAC,iBACAqB,aACAQ,oBACAmC,cACAkE,cACAI,oBACAK,eACAK,gBACAE,eACAG,aACAvF,cAEJrG,WACI4F,aACApB,YACAuG,eAEJ7T,SACIiH,eACAgD,mBACAY,aACAO,YACAC,iBACAqB,aACAQ,oBACAmC,cACAkE,cACAI,oBACAK,eACAK,gBACAE,eACAG,aACAvF,kBAKpB8F,iBAAiBvP,eAAiB,WAAc,UACzCuP,iBApDY,GAuDvBjV,QAAQiH,eAAiBA,eACzBjH,QAAQ2F,kBAAoBA,kBAC5B3F,QAAQgJ,yBAA2BA,yBACnChJ,QAAQiK,mBAAqBA,mBAC7BjK,QAAQ6K,aAAeA,aACvB7K,QAAQoL,YAAcA,YACtBpL,QAAQqL,iBAAmBA,iBAC3BrL,QAAQ0M,aAAeA,aACvB1M,QAAQkN,oBAAsBA,oBAC9BlN,QAAQqP,cAAgBA,cACxBrP,QAAQuT,cAAgBA,cACxBvT,QAAQ2T,oBAAsBA,oBAC9B3T,QAAQgU,eAAiBA,eACzBhU,QAAQqU,gBAAkBA,gBAC1BrU,QAAQuU,eAAiBA,eACzBvU,QAAQ0U,aAAeA,aACvB1U,QAAQmP,aAAeA,aACvBnP,QAAQ6B,WAAaA,WACrB7B,QAAQ6N,aAAeA,aACvB7N,QAAQ0O,aAAeA,aACvB1O,QAAQsN,YAAcA,YACtBtN,QAAQ6T,cAAgBA,cACxB7T,QAAQ6J,iBAAmBA,iBAC3B7J,QAAQyS,KAAOA,KACfzS,QAAQsK,WAAaA,WACrBtK,QAAQ+K,UAAYA,UACpB/K,QAAQiV,iBAAmBA,iBAE3B3T,OAAOiU,eAAevV,QAAS,cAAgBwV,OAAO","file":"src/ngx.leaflet.components.umd.min.js.map","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Observable'), require('@angular/http'), require('rxjs/add/operator/map'), require('rxjs/add/operator/catch'), require('@angular/common')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Observable', '@angular/http', 'rxjs/add/operator/map', 'rxjs/add/operator/catch', '@angular/common'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.ngxLeafletComponents = {}),global.ng.core,global.Rx,global.ng.http,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.common));\n}(this, (function (exports,core,Observable,http,map,_catch,common) { 'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MapService = (function () {\n    function MapService() {\n        this.basemaps = {};\n        this.overlays = {};\n        this.layerControlflag = false;\n        this.layersInControlNumber = 0;\n        this.layerControlObject = {};\n        this.groupIdentifiers = [];\n        this.groupNames = [];\n    }\n    /**\n     * @param {?} map\n     * @return {?}\n     */\n    MapService.prototype.setMap = /**\n     * @param {?} map\n     * @return {?}\n     */\n    function (map$$1) {\n        this.map = map$$1;\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getMap = /**\n     * @return {?}\n     */\n    function () {\n        return this.map;\n    };\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    MapService.prototype.setLayerControl = /**\n     * @param {?} state\n     * @return {?}\n     */\n    function (state) {\n        this.layerControlflag = state;\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getLayerControl = /**\n     * @return {?}\n     */\n    function () {\n        return this.layerControlflag;\n    };\n    /**\n     * @param {?} basemap\n     * @param {?} name\n     * @return {?}\n     */\n    MapService.prototype.addBasemap = /**\n     * @param {?} basemap\n     * @param {?} name\n     * @return {?}\n     */\n    function (basemap, name) {\n        if (name === '') {\n            name = 'unknown layer';\n        }\n        if (this.basemaps[name] === undefined) {\n            this.basemaps[name] = basemap;\n        }\n        else {\n            name = this.getUniqueName(name);\n            this.addBasemap(basemap, name);\n        }\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    MapService.prototype.getUniqueName = /**\n     * @param {?} name\n     * @return {?}\n     */\n    function (name) {\n        var /** @type {?} */ nameindex = 0;\n        var /** @type {?} */ newName = name;\n        if (name.indexOf('(') !== -1) {\n            nameindex = parseInt(name.split('(')[1].split(')')[0]);\n            nameindex += 1;\n            newName = name.split('(')[0];\n        }\n        else {\n            nameindex = 1;\n        }\n        return name = newName + '(' + nameindex + ')';\n    };\n    /**\n     * @param {?} overlay\n     * @param {?} name\n     * @param {?=} gId\n     * @return {?}\n     */\n    MapService.prototype.addOverlay = /**\n     * @param {?} overlay\n     * @param {?} name\n     * @param {?=} gId\n     * @return {?}\n     */\n    function (overlay, name, gId) {\n        if (this.groupIdentifiers.indexOf(gId) !== -1) {\n            var /** @type {?} */ index = this.groupIdentifiers.indexOf(gId);\n            var /** @type {?} */ existing_name = this.groupNames[index];\n            this.overlays[existing_name] = overlay;\n        }\n        else {\n            if (name === '') {\n                name = 'unknown group';\n            }\n            if (this.overlays[name] === undefined) {\n                this.groupNames.push(name);\n                this.groupIdentifiers.push(gId);\n                this.overlays[name] = overlay;\n            }\n            else {\n                name = this.getUniqueName(name);\n                if (this.groupNames.indexOf(name) === -1) {\n                    this.groupNames.push(name);\n                    this.groupIdentifiers.push(gId);\n                }\n                else {\n                    this.addOverlay(overlay, name);\n                }\n            }\n        }\n        this.addControl();\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getBasemaps = /**\n     * @return {?}\n     */\n    function () {\n        return this.basemaps;\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getOverlays = /**\n     * @return {?}\n     */\n    function () {\n        return this.overlays;\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getObservableOverlays = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return Observable.Observable.create(function (observer) {\n            observer.next(_this.overlays);\n            observer.complete();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getObservableBasemaps = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return Observable.Observable.create(function (observer) {\n            observer.next(_this.basemaps);\n            observer.complete();\n        });\n    };\n    /**\n     * @param {?} remove\n     * @param {?} add\n     * @return {?}\n     */\n    MapService.prototype.refreshOverlays = /**\n     * @param {?} remove\n     * @param {?} add\n     * @return {?}\n     */\n    function (remove, add) {\n        var /** @type {?} */ overlays = this.getOverlays();\n        for (var /** @type {?} */ key in overlays) {\n            if (overlays[key] instanceof Array) {\n                overlays[key].forEach(function (element, index, arr) {\n                    if (element._leaflet_id == remove._leaflet_id) {\n                        arr[index] = add;\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.increaseNumber = /**\n     * @return {?}\n     */\n    function () {\n        this.layersInControlNumber += 1;\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.getLayerNumber = /**\n     * @return {?}\n     */\n    function () {\n        return this.layersInControlNumber;\n    };\n    /**\n     * @return {?}\n     */\n    MapService.prototype.addControl = /**\n     * @return {?}\n     */\n    function () {\n        if (this.layerControlflag) {\n            var /** @type {?} */ map$$1 = this.getMap();\n            if (Object.keys(this.layerControlObject).length !== 0) {\n                this.layerControlObject.getContainer().innerHTML = '';\n                map$$1.removeControl(this.layerControlObject);\n            }\n            this.layerControlObject = L.control.layers(this.getBasemaps(), this.getOverlays()).addTo(map$$1);\n        }\n    };\n    MapService.decorators = [\n        { type: core.Injectable },\n    ];\n    /** @nocollapse */\n    MapService.ctorParameters = function () { return []; };\n    return MapService;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CoordinateHandler = (function () {\n    function CoordinateHandler() {\n    }\n    /**\n     * @return {?}\n     */\n    CoordinateHandler.prototype.assignCartesianPointToLeafletsLatLngSchema = /**\n     * @return {?}\n     */\n    function () {\n        if (this.x !== undefined) {\n            this.lon = this.x;\n        }\n        if (this.y !== undefined) {\n            this.lat = this.y;\n        }\n    };\n    /**\n     * @param {?=} arr\n     * @return {?}\n     */\n    CoordinateHandler.prototype.assignCartesianArrayToLeafletsLatLngSchema = /**\n     * @param {?=} arr\n     * @return {?}\n     */\n    function (arr) {\n        if (this.xys !== undefined) {\n            if (!arr) {\n                arr = this.xys;\n            }\n            for (var /** @type {?} */ i = 0; i < arr.length; i++) {\n                if (typeof (arr[0]) !== \"number\") {\n                    this.assignCartesianArrayToLeafletsLatLngSchema(arr[i]);\n                }\n                else {\n                    arr.reverse();\n                }\n            }\n            this.latlngs = this.xys;\n        }\n    };\n    /**\n     * @param {?} crs\n     * @return {?}\n     */\n    CoordinateHandler.prototype.transformPointCoordinates = /**\n     * @param {?} crs\n     * @return {?}\n     */\n    function (crs) {\n        /**\n                 * this is because leaflet default CRS is 3857 (so it can render wms properly)\n                 * but uses 4326 everywhere else so if CRS is 3857 don't reproject coordinates\n                 * also proj4 by default unprojects (inverse) to wgs84 (4326) which is handy but\n                 * doesnt match leaflet's default projection. Generally I don't really agree on\n                 * how leaflet doesn't handle projections on a global state\n                 */\n        if (crs.code && crs.code !== \"EPSG:3857\") {\n            var /** @type {?} */ newlatlng = crs.unproject({ y: this.lat, x: this.lon });\n            this.setNewLatLng(newlatlng);\n        }\n        else {\n            var /** @type {?} */ newlatlng = { lat: this.lat, lng: this.lon };\n            this.setNewLatLng(newlatlng);\n        }\n    };\n    /**\n     * @param {?} newlatlng\n     * @return {?}\n     */\n    CoordinateHandler.prototype.setNewLatLng = /**\n     * @param {?} newlatlng\n     * @return {?}\n     */\n    function (newlatlng) {\n        this.lat = newlatlng.lat;\n        this.lon = newlatlng.lng;\n    };\n    /**\n     * @param {?} crs\n     * @param {?=} arr\n     * @return {?}\n     */\n    CoordinateHandler.prototype.transformArrayCoordinates = /**\n     * @param {?} crs\n     * @param {?=} arr\n     * @return {?}\n     */\n    function (crs, arr) {\n        if (!arr) {\n            arr = this.latlngs;\n        }\n        for (var /** @type {?} */ i = 0; i < arr.length; i++) {\n            if (typeof (arr[0]) !== \"number\") {\n                arr[i] = this.transformArrayCoordinates(crs, arr[i]);\n            }\n            else {\n                if (crs.code && crs.code !== \"EPSG:3857\") {\n                    var /** @type {?} */ trasformed = crs.unproject({ x: arr[0], y: arr[1] });\n                    arr = { lat: trasformed.lat, lng: trasformed.lng };\n                }\n                else {\n                    arr = { lat: arr[0], lng: arr[1] };\n                }\n            }\n        }\n        return arr;\n    };\n    CoordinateHandler.propDecorators = {\n        \"lat\": [{ type: core.Input },],\n        \"lon\": [{ type: core.Input },],\n        \"x\": [{ type: core.Input },],\n        \"y\": [{ type: core.Input },],\n        \"latlngs\": [{ type: core.Input },],\n        \"xys\": [{ type: core.Input },],\n    };\n    return CoordinateHandler;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LeafletElement = (function (_super) {\n    __extends(LeafletElement, _super);\n    function LeafletElement(mapService) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.lat = 52.6;\n        _this.lon = -1.1;\n        _this.zoom = 12;\n        _this.minZoom = 4;\n        _this.maxZoom = 19;\n        _this.layerControl = false;\n        _this.crs = L.CRS.EPSG3857;\n        _this.maxBounds = null;\n        _this.layerControlObject = null;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    LeafletElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianPointToLeafletsLatLngSchema.call(this);\n        if (typeof (this.crs) === \"string\") {\n            var /** @type {?} */ splitCrs = this.crs.split(\".\");\n            if (splitCrs[0] === \"L\") {\n                this.crs = L[splitCrs[1]][splitCrs[2]];\n            }\n            else {\n                console.warn(\"something is not right, reverting to default EPSG3857\");\n                this.crs = L.CRS.EPSG3857;\n            }\n        }\n        _super.prototype.transformPointCoordinates.call(this, this.crs);\n        var /** @type {?} */ map$$1 = L.map(this.mapElement.nativeElement, {\n            crs: this.crs,\n            zoomControl: this.zoomControl,\n            center: L.latLng(this.lat, this.lon),\n            zoom: this.zoom,\n            minZoom: this.minZoom,\n            maxZoom: this.maxZoom,\n            maxBounds: this.maxBounds,\n            layers: [],\n            closePopupOnClick: false,\n            attributionControl: false\n        });\n        this.mapElement.nativeElement.myMapProperty = map$$1;\n        //set variables for childrent components\n        this.mapService.setMap(map$$1);\n        this.mapService.setLayerControl(this.layerControl);\n    };\n    /**\n     * @return {?}\n     */\n    LeafletElement.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n    };\n    /**\n     * @return {?}\n     */\n    LeafletElement.prototype.setLayerControl = /**\n     * @return {?}\n     */\n    function () {\n        if (this.layerControl) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            if (this.layerControlObject !== null) {\n                this.layerControlObject.getContainer().innerHTML = '';\n            }\n            this.layerControlObject = L.control.layers(this.mapService.getBasemaps(), this.mapService.getOverlays()).addTo(map$$1);\n        }\n    };\n    LeafletElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'leaf-element',\n                    template: \"\\n  <div class=\\\"page-background map-container\\\" layout-padding>\\n\\t  <div #map></div>\\n  </div>\",\n                    styles: [\n                        ':host {width: 100%;height:100%;}' +\n                            ':host .map-container {position: absolute;display: block;top: 0px;left: 0px;right: 0px;bottom: 0px;}' +\n                            'leaf-element{width:100%;}' +\n                            '.leaflet-pane {z-index: 0 !important;}' +\n                            '.leaflet-bottom.leaflet-left {z-index: 1 !important;}'\n                    ],\n                    providers: [MapService]\n                },] },\n    ];\n    /** @nocollapse */\n    LeafletElement.ctorParameters = function () { return [\n        { type: MapService, },\n    ]; };\n    LeafletElement.propDecorators = {\n        \"lat\": [{ type: core.Input },],\n        \"lon\": [{ type: core.Input },],\n        \"zoom\": [{ type: core.Input },],\n        \"minZoom\": [{ type: core.Input },],\n        \"maxZoom\": [{ type: core.Input },],\n        \"layerControl\": [{ type: core.Input },],\n        \"crs\": [{ type: core.Input },],\n        \"zoomControl\": [{ type: core.Input },],\n        \"maxBounds\": [{ type: core.Input },],\n        \"mapElement\": [{ type: core.ViewChild, args: ['map',] },],\n    };\n    return LeafletElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar GeoJSONCoordinateHandler = (function () {\n    function GeoJSONCoordinateHandler() {\n        this.geojson = {};\n    }\n    /**\n     * @param {?} geoJSON\n     * @param {?} crs\n     * @return {?}\n     */\n    GeoJSONCoordinateHandler.prototype.transformJSONCoordinates = /**\n     * @param {?} geoJSON\n     * @param {?} crs\n     * @return {?}\n     */\n    function (geoJSON, crs) {\n        var _this = this;\n        /**\n                 * 7.  GeoJSON Types Are Not Extensible\n                 * Implementations MUST NOT extend the fixed set of GeoJSON types:\n                 * FeatureCollection, Feature, Point, LineString, MultiPoint, Polygon,\n                 * MultiLineString, MultiPolygon, and GeometryCollection.\n                 */\n        if (geoJSON.type === \"FeatureCollection\") {\n            var /** @type {?} */ featureCollection = geoJSON;\n            featureCollection.features.forEach(function (feature) {\n                _this.transformJSONCoordinates(feature, crs);\n            });\n        }\n        if (geoJSON.type === \"Feature\") {\n            var /** @type {?} */ feature = geoJSON;\n            this.transformJSONCoordinates(feature.geometry, crs);\n        }\n        if (geoJSON.type === \"Point\") {\n            var /** @type {?} */ point = geoJSON;\n            point = this.transformPointCoordinates(point.coordinates, crs);\n        }\n        if (geoJSON.type === \"LineString\") {\n            var /** @type {?} */ lineString = geoJSON;\n            lineString.coordinates.forEach(function (point) {\n                _this.transformPointCoordinates(point, crs);\n            });\n        }\n        if (geoJSON.type === \"MultiPoint\") {\n            var /** @type {?} */ multiPoint = geoJSON;\n            multiPoint.coordinates.forEach(function (point) {\n                _this.transformPointCoordinates(point, crs);\n            });\n        }\n        if (geoJSON.type === \"Polygon\") {\n            var /** @type {?} */ polygon = geoJSON;\n            polygon.coordinates.forEach(function (polygonElement) {\n                polygonElement.forEach(function (point) {\n                    _this.transformPointCoordinates(point, crs);\n                });\n            });\n        }\n        if (geoJSON.type === \"MultiLineString\") {\n            var /** @type {?} */ multiLineString = geoJSON;\n            multiLineString.coordinates.forEach(function (lineString) {\n                lineString.forEach(function (point) {\n                    _this.transformPointCoordinates(point, crs);\n                });\n            });\n        }\n        if (geoJSON.type === \"MultiPolygon\") {\n            var /** @type {?} */ multiPolygon = geoJSON;\n            multiPolygon.coordinates.forEach(function (polygon) {\n                polygon.forEach(function (polygonElement) {\n                    polygonElement.forEach(function (point) {\n                        _this.transformPointCoordinates(point, crs);\n                    });\n                });\n            });\n        }\n        if (geoJSON.type === \"GeometryCollection\") {\n            var /** @type {?} */ geometryCollection = geoJSON;\n            geometryCollection.geometries.forEach(function (geometry) {\n                _this.transformJSONCoordinates(geometry, crs);\n            });\n        }\n    };\n    /**\n     * @param {?} point\n     * @param {?} crs\n     * @return {?}\n     */\n    GeoJSONCoordinateHandler.prototype.transformPointCoordinates = /**\n     * @param {?} point\n     * @param {?} crs\n     * @return {?}\n     */\n    function (point, crs) {\n        /**\n                 * this is because leaflet default CRS is 3857 (so it can render wms properly)\n                 * but uses 4326 everywhere else so if CRS is 3857 don't reproject coordinates\n                 * also proj4 by default unprojects (inverse) to wgs84 (4326) which is handy but\n                 * doesnt match leaflet's default projection. Generally I don't really agree on\n                 * how leaflet doesn't handle projections on a global state\n                 */\n        if (crs.code && crs.code !== \"EPSG:3857\") {\n            var /** @type {?} */ newlatlng = crs.unproject({ x: point[0], y: point[1] });\n            point[1] = newlatlng.lat;\n            point[0] = newlatlng.lng;\n            return point;\n        }\n        else {\n            return point;\n        }\n    };\n    GeoJSONCoordinateHandler.propDecorators = {\n        \"geojson\": [{ type: core.Input },],\n    };\n    return GeoJSONCoordinateHandler;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar attributionModel = (function () {\n    function attributionModel(options) {\n        this.prefix = \"Leaflet\";\n        this.position = \"bottomright\";\n        if (options !== null) {\n            for (var /** @type {?} */ key in options) {\n                if (options[key] !== undefined) {\n                    this[key] = options[key];\n                }\n            }\n        }\n    }\n    return attributionModel;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar AttributionControl = (function () {\n    function AttributionControl(mapService, LeafletElement$$1) {\n        this.mapService = mapService;\n        this.LeafletElement = LeafletElement$$1;\n        this.Options = new attributionModel(null);\n    }\n    /**\n     * @return {?}\n     */\n    AttributionControl.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (this.LeafletElement) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            L.control.attribution(this.Options).addTo(map$$1);\n        }\n        else {\n            console.warn(\"This attribution-control will not be rendered \\n the expected parent node of attribution-control should be either leaf-element or layer-element\");\n        }\n    };\n    AttributionControl.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'attribution-control',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    AttributionControl.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n    ]; };\n    AttributionControl.propDecorators = {\n        \"Options\": [{ type: core.Input },],\n    };\n    return AttributionControl;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar scaleModel = (function () {\n    function scaleModel(options) {\n        this.maxWidth = 100;\n        this.metric = true;\n        this.imperial = true;\n        this.updateWhenIdle = true;\n        this.position = \"bottomleft\";\n        var /** @type {?} */ source = options;\n        var /** @type {?} */ copy = this;\n        if (source !== null) {\n            for (var /** @type {?} */ key in source) {\n                if (source[key] !== undefined) {\n                    copy[key] = source[key];\n                }\n            }\n        }\n    }\n    return scaleModel;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ScaleControl = (function () {\n    function ScaleControl(mapService, LeafletElement$$1) {\n        this.mapService = mapService;\n        this.LeafletElement = LeafletElement$$1;\n        this.Options = new scaleModel(null);\n    }\n    /**\n     * @return {?}\n     */\n    ScaleControl.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (this.LeafletElement) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            L.control.scale(this.Options).addTo(map$$1);\n        }\n        else {\n            console.warn(\"This scale-control will not be rendered \\n the expected parent node of scale-control should be leaf-element\");\n        }\n    };\n    ScaleControl.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'scale-control',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    ScaleControl.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n    ]; };\n    ScaleControl.propDecorators = {\n        \"Options\": [{ type: core.Input },],\n    };\n    return ScaleControl;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar zoomModel = (function () {\n    function zoomModel(options) {\n        this.zoomInText = \"+\";\n        this.zoomInTitle = \"Zoom in\";\n        this.zoomOutText = \"-\";\n        this.zoomOutTitle = \"Zoom out\";\n        this.position = \"topright\";\n        var /** @type {?} */ source = options;\n        var /** @type {?} */ copy = this;\n        if (source !== null) {\n            for (var /** @type {?} */ key in source) {\n                if (source[key] !== undefined) {\n                    copy[key] = source[key];\n                }\n            }\n        }\n    }\n    return zoomModel;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ZoomControl = (function () {\n    function ZoomControl(mapService, LeafletElement$$1) {\n        this.mapService = mapService;\n        this.LeafletElement = LeafletElement$$1;\n        this.Options = new zoomModel(null);\n    }\n    /**\n     * @return {?}\n     */\n    ZoomControl.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (this.LeafletElement) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            L.control.zoom(this.Options).addTo(map$$1);\n        }\n        else {\n            console.warn(\"This zoom-control will not be rendered \\n the expected parent node of zoom-control should be leaf-element\");\n        }\n    };\n    ZoomControl.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'zoom-control',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    ZoomControl.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n    ]; };\n    ZoomControl.propDecorators = {\n        \"Options\": [{ type: core.Input },],\n    };\n    return ZoomControl;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar WatermarkControl = (function () {\n    function WatermarkControl(mapService, LeafletElement$$1) {\n        this.mapService = mapService;\n        this.LeafletElement = LeafletElement$$1;\n    }\n    /**\n     * @return {?}\n     */\n    WatermarkControl.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ self = this;\n        if (this.LeafletElement) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            if (this.url) {\n                L.Control['Watermark'] = /** @type {?} */ ({});\n                L.Control['Watermark'] = L.Control.extend({\n                    onAdd: function (map$$1) {\n                        var /** @type {?} */ basediv = L.DomUtil.create('div', 'watermark');\n                        var /** @type {?} */ howManyInX = Math.ceil(map$$1.getSize().x / self.imagewidth);\n                        var /** @type {?} */ howManyInY = Math.ceil(map$$1.getSize().y / self.imageheight);\n                        var /** @type {?} */ numberOfLogo = howManyInX * howManyInY;\n                        console.log(numberOfLogo);\n                        var /** @type {?} */ i = 0;\n                        for (i; i < numberOfLogo; i++) {\n                            var /** @type {?} */ img = L.DomUtil.create('img', 'watermark-elements', basediv);\n                            img.src = self.url;\n                            img.style.width = self.imagewidth + 'px';\n                        }\n                        return basediv;\n                    },\n                    onRemove: function (map$$1) {\n                    }\n                });\n                L.control['watermark'] = function (opts) {\n                    return new L.Control['Watermark'](opts);\n                };\n            }\n            L.control['watermark']({ position: \"bottomleft\" }).addTo(map$$1);\n        }\n    };\n    WatermarkControl.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'watermark-element',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    WatermarkControl.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n    ]; };\n    WatermarkControl.propDecorators = {\n        \"url\": [{ type: core.Input },],\n        \"imagewidth\": [{ type: core.Input },],\n        \"imageheight\": [{ type: core.Input },],\n    };\n    return WatermarkControl;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LayerElement = (function () {\n    function LayerElement(mapService) {\n        this.mapService = mapService;\n        this.slippyLayer = '';\n        this.wmsLayer = '';\n        this.name = '';\n        this.opacity = 1;\n        this.type = 'overlay';\n        this.attribution = null;\n    }\n    /**\n     * @return {?}\n     */\n    LayerElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this.mapService.increaseNumber();\n        var /** @type {?} */ map$$1 = this.mapService.getMap();\n        var /** @type {?} */ layer = null;\n        if (this.slippyLayer !== \"\") {\n            layer = L.tileLayer(this.slippyLayer, {\n                attribution: this.attribution,\n            });\n        }\n        if (this.wmsLayer !== \"\" && this.name !== \"\") {\n            layer = L.tileLayer.wms(this.wmsLayer, {\n                layers: this.name,\n                attribution: this.attribution\n            }).setOpacity(this.opacity);\n        }\n        if (layer !== {}) {\n            if (this.type === \"overlay\") {\n                this.mapService.addOverlay(layer, this.name);\n                layer.addTo(map$$1);\n            }\n            else if (this.type === \"basemap\") {\n                this.mapService.addBasemap(layer, this.name);\n                layer.addTo(map$$1);\n            }\n        }\n    };\n    LayerElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'layer-element',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    LayerElement.ctorParameters = function () { return [\n        { type: MapService, },\n    ]; };\n    LayerElement.propDecorators = {\n        \"slippyLayer\": [{ type: core.Input },],\n        \"wmsLayer\": [{ type: core.Input },],\n        \"name\": [{ type: core.Input },],\n        \"opacity\": [{ type: core.Input },],\n        \"type\": [{ type: core.Input },],\n        \"attribution\": [{ type: core.Input },],\n    };\n    return LayerElement;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ImageOverlayElement = (function (_super) {\n    __extends(ImageOverlayElement, _super);\n    function ImageOverlayElement(mapService, LeafletElement$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.bounds = [[-26.5, -25], [1021.5, 1023]];\n        _this.imagepath = '';\n        _this.name = '';\n        _this.opacity = 1;\n        _this.type = 'overlay';\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    ImageOverlayElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this.latlngs = this.bounds;\n        if (this.LeafletElement) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            _super.prototype.transformArrayCoordinates.call(this, this.LeafletElement.crs);\n            var /** @type {?} */ layer = null;\n            layer = L.imageOverlay(this.imagepath, this.bounds).setOpacity(this.opacity);\n            if (layer !== {}) {\n                if (this.type === \"overlay\") {\n                    this.mapService.addOverlay(layer, this.name);\n                    layer.addTo(map$$1);\n                }\n                else if (this.type === \"basemap\") {\n                    this.mapService.addBasemap(layer, this.name);\n                }\n            }\n        }\n    };\n    ImageOverlayElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'image-overlay-element',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    ImageOverlayElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n    ]; };\n    ImageOverlayElement.propDecorators = {\n        \"bounds\": [{ type: core.Input },],\n        \"imagepath\": [{ type: core.Input },],\n        \"name\": [{ type: core.Input },],\n        \"opacity\": [{ type: core.Input },],\n        \"type\": [{ type: core.Input },],\n    };\n    return ImageOverlayElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar GuidService = (function () {\n    function GuidService() {\n    }\n    /**\n     * @return {?}\n     */\n    GuidService.prototype.newGuid = /**\n     * @return {?}\n     */\n    function () {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var /** @type {?} */ r = Math.random() * 16 | 0, /** @type {?} */ v = c == 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    };\n    GuidService.decorators = [\n        { type: core.Injectable },\n    ];\n    /** @nocollapse */\n    GuidService.ctorParameters = function () { return []; };\n    return GuidService;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar GroupService = (function () {\n    function GroupService(guidService) {\n        this.guidService = guidService;\n        this.layerGroup = [];\n        this.layerId = [];\n        this.layerGroupNumber = 0;\n        this.group = {};\n    }\n    /**\n     * @param {?} overlay\n     * @param {?} map\n     * @param {?} mapService\n     * @param {?} group\n     * @param {?=} replace\n     * @param {?=} gId\n     * @return {?}\n     */\n    GroupService.prototype.addOLayersToGroup = /**\n     * @param {?} overlay\n     * @param {?} map\n     * @param {?} mapService\n     * @param {?} group\n     * @param {?=} replace\n     * @param {?=} gId\n     * @return {?}\n     */\n    function (overlay, map$$1, mapService, group, replace, gId) {\n        if (replace === void 0) { replace = false; }\n        if (!gId) {\n            gId = this.guidService.newGuid();\n        }\n        if (this.layerId.indexOf(gId) === -1) {\n            this.layerId.push(gId);\n        }\n        if (Object.keys(this.group).length !== 0) {\n            if (replace) {\n                map$$1.removeLayer(this.group);\n                if (this.layerId.indexOf(gId) !== -1) {\n                    this.layerGroup[this.layerId.indexOf(gId)] = overlay;\n                }\n                else {\n                    this.layerGroup.push(overlay);\n                }\n                this.group = L.layerGroup(this.getLayerGroup());\n                this.group.addTo(map$$1);\n            }\n            else {\n                this.layerGroup.push(overlay);\n                this.group.addLayer(overlay);\n            }\n        }\n        if (!replace) {\n            this.layerGroup.push(overlay);\n            this.group = L.layerGroup(this.getLayerGroup());\n            this.group.addTo(map$$1);\n        }\n        mapService.addOverlay(this.getGroup(), group.name, group.globalId);\n    };\n    /**\n     * @return {?}\n     */\n    GroupService.prototype.getObservableGroup = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return Observable.Observable.create(function (observer) {\n            var /** @type {?} */ group = _this.getGroup();\n            observer.next(group);\n            observer.complete();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    GroupService.prototype.getGroup = /**\n     * @return {?}\n     */\n    function () {\n        return this.group;\n    };\n    /**\n     * @return {?}\n     */\n    GroupService.prototype.getLayerGroup = /**\n     * @return {?}\n     */\n    function () {\n        return this.layerGroup;\n    };\n    /**\n     * @return {?}\n     */\n    GroupService.prototype.getLayerNumber = /**\n     * @return {?}\n     */\n    function () {\n        return this.layerGroupNumber;\n    };\n    GroupService.decorators = [\n        { type: core.Injectable },\n    ];\n    /** @nocollapse */\n    GroupService.ctorParameters = function () { return [\n        { type: GuidService, },\n    ]; };\n    return GroupService;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar PopupService = (function () {\n    function PopupService() {\n    }\n    /**\n     * @param {?} mouseover\n     * @param {?} onclick\n     * @param {?} element\n     * @param {?} text\n     * @return {?}\n     */\n    PopupService.prototype.enablePopup = /**\n     * @param {?} mouseover\n     * @param {?} onclick\n     * @param {?} element\n     * @param {?} text\n     * @return {?}\n     */\n    function (mouseover, onclick, element, text) {\n        if (mouseover && onclick) {\n            mouseover = undefined;\n            console.warn('you can not use mouseover and onclick at the same time, mouseover is going to be depressed');\n        }\n        if (mouseover) {\n            if (mouseover === 'true' && text) {\n                mouseover = text;\n            }\n            else if (mouseover === true && !text) {\n                mouseover = \"true\";\n            }\n            element.bindPopup(mouseover);\n            element.on('mouseover', function () {\n                this.openPopup();\n            }).on('mouseout', function () {\n                this.closePopup();\n            });\n        }\n        if (onclick) {\n            if (onclick === 'true' && text) {\n                onclick = text;\n            }\n            else if (onclick === true && !text) {\n                onclick = \"true\";\n            }\n            element.bindPopup(onclick);\n            element.on('click', function () {\n                this.openPopup();\n            });\n        }\n        if (!mouseover && !onclick && text) {\n            element.bindPopup(text);\n            element.on('mouseover', function () {\n                this.openPopup();\n            }).on('mouseout', function () {\n                this.closePopup();\n            });\n        }\n    };\n    PopupService.decorators = [\n        { type: core.Injectable },\n    ];\n    /** @nocollapse */\n    PopupService.ctorParameters = function () { return []; };\n    return PopupService;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LeafletGroup = (function () {\n    function LeafletGroup(mapService, groupService, guidService) {\n        this.mapService = mapService;\n        this.groupService = groupService;\n        this.guidService = guidService;\n        this.name = '';\n        this.globalId = this.guidService.newGuid();\n    }\n    /**\n     * @return {?}\n     */\n    LeafletGroup.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n    };\n    /**\n     * @return {?}\n     */\n    LeafletGroup.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n    };\n    LeafletGroup.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'leaflet-group',\n                    template: \"\",\n                    styles: [''],\n                    providers: [GroupService]\n                },] },\n    ];\n    /** @nocollapse */\n    LeafletGroup.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: GroupService, },\n        { type: GuidService, },\n    ]; };\n    LeafletGroup.propDecorators = {\n        \"name\": [{ type: core.Input },],\n    };\n    return LeafletGroup;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MarkerElement = (function (_super) {\n    __extends(MarkerElement, _super);\n    function MarkerElement(mapService, popupService, http$$1, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.popupService = popupService;\n        _this.http = http$$1;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.lat = 52.6;\n        _this.lon = -1.1;\n        _this.mouseover = undefined;\n        _this.onclick = undefined;\n        _this.iconUrl = \"\";\n        _this.marker = null;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    MarkerElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianPointToLeafletsLatLngSchema.call(this);\n        var /** @type {?} */ model = this;\n        if (this.LeafletElement || this.LeafletGroup) {\n            var /** @type {?} */ map_1 = this.mapService.getMap();\n            _super.prototype.transformPointCoordinates.call(this, this.LeafletElement.crs);\n            if (this.iconUrl === \"\") {\n                this.marker = L.marker([this.lat, this.lon]);\n                this.createMarkerlayer(this.marker, map_1);\n            }\n            else {\n                this.imageExists(this.iconUrl, function (exists) {\n                    model.getImage().subscribe(function (image) {\n                        var /** @type {?} */ img = document.createElement(\"img\");\n                        window.URL.createObjectURL(image.blob());\n                        var /** @type {?} */ reader = new FileReader();\n                        reader.onload = function () {\n                            img.src = reader.result;\n                            var /** @type {?} */ myIcon = L.icon({\n                                iconUrl: model.iconUrl,\n                                iconSize: [img.width, img.height],\n                                iconAnchor: [img.width / 2, img.height - 1],\n                                popupAnchor: [0, -img.height]\n                            });\n                            var /** @type {?} */ obj = { icon: myIcon, options: null };\n                            model.marker = L.marker([model.lat, model.lon], obj);\n                            model.createMarkerlayer(model.marker, map_1);\n                        };\n                        reader.readAsDataURL(image.blob());\n                    }, function (err) {\n                        console.log(err);\n                    });\n                });\n            }\n        }\n        else {\n            console.warn(\"This marker-element will not be rendered \\n the expected parent node of marker-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    /**\n     * @param {?} marker\n     * @param {?} map\n     * @return {?}\n     */\n    MarkerElement.prototype.createMarkerlayer = /**\n     * @param {?} marker\n     * @param {?} map\n     * @return {?}\n     */\n    function (marker, map$$1) {\n        var /** @type {?} */ textInput = undefined;\n        if (this.ngEl.nativeElement.childNodes.length > 0) {\n            var /** @type {?} */ textNode = this.ngEl.nativeElement.childNodes[0];\n            textInput = textNode.nodeValue;\n        }\n        //add popup methods on element only if any of the tests are not undefined\n        if (this.mouseover !== undefined || this.onclick !== undefined || textInput !== undefined) {\n            this.popupService.enablePopup(this.mouseover, this.onclick, this.marker, textInput);\n        }\n        //only if the parent is map should the marker-element should be directly added to the map\n        if (this.LeafletGroup) {\n            this.groupService.addOLayersToGroup(marker, map$$1, this.mapService, this.LeafletGroup);\n        }\n        else {\n            marker.addTo(map$$1);\n        }\n    };\n    /**\n     * @param {?} url\n     * @param {?} callback\n     * @return {?}\n     */\n    MarkerElement.prototype.imageExists = /**\n     * @param {?} url\n     * @param {?} callback\n     * @return {?}\n     */\n    function (url, callback) {\n        var /** @type {?} */ img = new Image();\n        img.onload = function () { callback(true); };\n        img.onerror = function () { callback(false); };\n        img.src = url;\n    };\n    /**\n     * @return {?}\n     */\n    MarkerElement.prototype.getImage = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ headers = new http.Headers({ 'Content-Type': 'application/x-www-form-urlencoded' });\n        var /** @type {?} */ options = new http.RequestOptions({\n            responseType: http.ResponseContentType.Blob,\n            headers: headers\n        });\n        return this.http.get(this.iconUrl, options)\n            .map(function (res) { return res; })\n            .catch(function (error) { return Observable.Observable.throw('Server error'); });\n    };\n    MarkerElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'marker-element',\n                    template: \"<div #ngel><ng-content></ng-content></div>\",\n                    styles: [''],\n                    providers: [PopupService]\n                },] },\n    ];\n    /** @nocollapse */\n    MarkerElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: PopupService, },\n        { type: http.Http, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    MarkerElement.propDecorators = {\n        \"lat\": [{ type: core.Input },],\n        \"lon\": [{ type: core.Input },],\n        \"mouseover\": [{ type: core.Input },],\n        \"onclick\": [{ type: core.Input },],\n        \"iconUrl\": [{ type: core.Input },],\n        \"ngEl\": [{ type: core.ViewChild, args: ['ngel',] },],\n    };\n    return MarkerElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar path = (function () {\n    function path(pathInfo) {\n        this.stroke = true;\n        this.color = '#3388ff';\n        this.weight = 3;\n        this.opacity = 1;\n        this.lineCap = 'round';\n        this.lineJoin = 'round';\n        this.dashArray = null;\n        this.dashOffset = null;\n        this.fill = true;\n        this.fillColor = '#3388ff';\n        this.fillOpacity = 0.2;\n        this.fillRule = 'evenodd';\n        //TODO renderer: Renderer; \t\tUse this specific instance of Renderer for this path. Takes precedence over the map's default renderer.\n        this.className = null;\n        var /** @type {?} */ source = pathInfo;\n        var /** @type {?} */ copy = this;\n        if (source !== null) {\n            for (var /** @type {?} */ key in source) {\n                if (source[key] !== undefined) {\n                    copy[key] = source[key];\n                }\n            }\n        }\n    }\n    return path;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CircleElement = (function (_super) {\n    __extends(CircleElement, _super);\n    function CircleElement(mapService, popupService, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.popupService = popupService;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.lat = 52.6;\n        _this.lon = -1.1;\n        _this.radius = 20;\n        _this.mouseover = undefined;\n        _this.onclick = undefined;\n        _this.Options = new path(null);\n        _this.circle = null;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    CircleElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianPointToLeafletsLatLngSchema.call(this);\n        //check if any of the two optional injections exist\n        if (this.LeafletElement || this.LeafletGroup) {\n            var /** @type {?} */ inheritedOptions = new path(this.Options);\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            _super.prototype.transformPointCoordinates.call(this, this.LeafletElement.crs);\n            this.circle = L.circle([this.lat, this.lon], this.radius, inheritedOptions);\n            if (this.LeafletGroup) {\n                this.groupService.addOLayersToGroup(this.circle, map$$1, this.mapService, this.LeafletGroup);\n            }\n            else {\n                this.circle.addTo(map$$1);\n            }\n        }\n        else {\n            console.warn(\"This circle-element will not be rendered \\n the expected parent node of circle-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CircleElement.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        if (this.LeafletElement || this.LeafletGroup) {\n            var /** @type {?} */ textInput = undefined;\n            if (this.ngEl.nativeElement.childNodes.length > 0) {\n                var /** @type {?} */ textNode = this.ngEl.nativeElement.childNodes[0];\n                textInput = textNode.nodeValue;\n            }\n            //add popup methods on element only if any of the tests are not undefined\n            if (this.mouseover !== undefined || this.onclick !== undefined || textInput !== undefined) {\n                this.popupService.enablePopup(this.mouseover, this.onclick, this.circle, textInput);\n            }\n        }\n    };\n    CircleElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'circle-element',\n                    template: \"<div #ngel><ng-content></ng-content></div>\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    CircleElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: PopupService, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    CircleElement.propDecorators = {\n        \"lat\": [{ type: core.Input },],\n        \"lon\": [{ type: core.Input },],\n        \"radius\": [{ type: core.Input },],\n        \"mouseover\": [{ type: core.Input },],\n        \"onclick\": [{ type: core.Input },],\n        \"Options\": [{ type: core.Input },],\n        \"ngEl\": [{ type: core.ViewChild, args: ['ngel',] },],\n    };\n    return CircleElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CircleMarkerElement = (function (_super) {\n    __extends(CircleMarkerElement, _super);\n    function CircleMarkerElement(mapService, popupService, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.popupService = popupService;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.lat = 52.6;\n        _this.lon = -1.1;\n        _this.mouseover = undefined;\n        _this.onclick = undefined;\n        _this.Options = new path(null);\n        _this.circle = null;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    CircleMarkerElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianPointToLeafletsLatLngSchema.call(this);\n        //check if any of the two optional injections exist\n        if (this.LeafletElement || this.LeafletGroup) {\n            var /** @type {?} */ inheritedOptions = new path(this.Options);\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            var /** @type {?} */ elementPosition = _super.prototype.transformPointCoordinates.call(this, this.LeafletElement.crs);\n            this.circle = L.circleMarker([this.lat, this.lon], inheritedOptions);\n            if (this.LeafletGroup) {\n                this.groupService.addOLayersToGroup(this.circle, map$$1, this.mapService, this.LeafletGroup);\n            }\n            else {\n                this.circle.addTo(map$$1);\n            }\n        }\n        else {\n            console.warn(\"This circle-element will not be rendered \\n the expected parent node of circle-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CircleMarkerElement.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ textInput = undefined;\n        if (this.ngEl.nativeElement.childNodes.length > 0) {\n            var /** @type {?} */ textNode = this.ngEl.nativeElement.childNodes[0];\n            textInput = textNode.nodeValue;\n        }\n        //add popup methods on element only if any of the tests are not undefined\n        if (this.mouseover !== undefined || this.onclick !== undefined || textInput !== undefined) {\n            this.popupService.enablePopup(this.mouseover, this.onclick, this.circle, textInput);\n        }\n    };\n    CircleMarkerElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'circle-marker-element',\n                    template: \"<div #ngel><ng-content></ng-content></div>\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    CircleMarkerElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: PopupService, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    CircleMarkerElement.propDecorators = {\n        \"lat\": [{ type: core.Input },],\n        \"lon\": [{ type: core.Input },],\n        \"mouseover\": [{ type: core.Input },],\n        \"onclick\": [{ type: core.Input },],\n        \"Options\": [{ type: core.Input },],\n        \"ngEl\": [{ type: core.ViewChild, args: ['ngel',] },],\n    };\n    return CircleMarkerElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar HelperService = (function () {\n    function HelperService() {\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    HelperService.prototype.arrayCompare = /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    function (a, b) {\n        if (a.length != b.length) {\n            return false;\n        }\n        for (var /** @type {?} */ i in a) {\n            // Don't forget to check for arrays in our arrays.\n            if (a[i] instanceof Array && b[i] instanceof Array) {\n                if (!this.arrayCompare(a[i], b[i])) {\n                    return false;\n                }\n            }\n            else if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    HelperService.decorators = [\n        { type: core.Injectable },\n    ];\n    /** @nocollapse */\n    HelperService.ctorParameters = function () { return []; };\n    return HelperService;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar PolygonElement = (function (_super) {\n    __extends(PolygonElement, _super);\n    function PolygonElement(mapService, popupService, guidService, helperService, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.popupService = popupService;\n        _this.guidService = guidService;\n        _this.helperService = helperService;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.latlngs = [[[52.65, -1.2], [52.645, -1.15], [52.696, -1.155], [52.697, -1.189]],\n            [[52.66, -1.19], [52.665, -1.16], [52.686, -1.161], [52.687, -1.179]]];\n        _this.Options = new path(null);\n        _this.mouseover = undefined;\n        _this.onclick = undefined;\n        _this.polygon = null;\n        _this.originalObject = _this.latlngs.slice();\n        _this.globalId = _this.guidService.newGuid();\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    PolygonElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianArrayToLeafletsLatLngSchema.call(this);\n        //check if any of the two optional injections exist\n        if (this.LeafletElement || this.LeafletGroup) {\n            var /** @type {?} */ inheritedOptions = new path(this.Options);\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            _super.prototype.transformArrayCoordinates.call(this, this.LeafletElement.crs);\n            this.polygon = L.polygon([this.latlngs], inheritedOptions);\n            if (this.LeafletGroup) {\n                this.groupService.addOLayersToGroup(this.polygon, map$$1, this.mapService, this.LeafletGroup, false, this.globalId);\n            }\n            else {\n                this.polygon.addTo(map$$1);\n            }\n        }\n        else {\n            console.warn(\"This polygon-element will not be rendered \\n the expected parent node of polygon-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PolygonElement.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ textInput = undefined;\n        if (this.ngEl.nativeElement.childNodes.length > 0) {\n            var /** @type {?} */ textNode = this.ngEl.nativeElement.childNodes[0];\n            textInput = textNode.nodeValue;\n        }\n        //add popup methods on element only if any of the tests are not undefined\n        if (this.mouseover !== undefined || this.onclick !== undefined || textInput !== undefined) {\n            this.popupService.enablePopup(this.mouseover, this.onclick, this.polygon, textInput);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PolygonElement.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ map$$1 = this.mapService.getMap();\n        var /** @type {?} */ same = this.helperService.arrayCompare(this.originalObject, this.latlngs);\n        if (!same) {\n            this.originalObject = this.latlngs.slice();\n            //if the layer is part of a group\n            var /** @type {?} */ inheritedOptions = new path(this.Options);\n            if (this.LeafletGroup) {\n                this.polygon = L.polygon([this.latlngs], inheritedOptions);\n                this.groupService.addOLayersToGroup(this.polygon, map$$1, this.mapService, this.LeafletGroup, true, this.globalId);\n            }\n            else {\n                map$$1.removeLayer(this.polygon);\n                this.polygon = L.polygon([this.latlngs], inheritedOptions);\n                this.polygon.addTo(map$$1);\n            }\n        }\n    };\n    PolygonElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'polygon-element',\n                    template: \"<div #ngel><ng-content></ng-content></div>\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    PolygonElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: PopupService, },\n        { type: GuidService, },\n        { type: HelperService, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    PolygonElement.propDecorators = {\n        \"latlngs\": [{ type: core.Input },],\n        \"Options\": [{ type: core.Input },],\n        \"mouseover\": [{ type: core.Input },],\n        \"onclick\": [{ type: core.Input },],\n        \"ngEl\": [{ type: core.ViewChild, args: ['ngel',] },],\n    };\n    return PolygonElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar PolylineElement = (function (_super) {\n    __extends(PolylineElement, _super);\n    function PolylineElement(mapService, popupService, guidService, helperService, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.popupService = popupService;\n        _this.guidService = guidService;\n        _this.helperService = helperService;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.latlngs = [[52.6, -1.1], [52.605, -1.1], [52.606, -1.105], [52.697, -1.109]];\n        _this.Options = new path(null);\n        _this.mouseover = undefined;\n        _this.onclick = undefined;\n        _this.polyline = null;\n        _this.originalObject = _this.latlngs.slice();\n        _this.globalId = _this.guidService.newGuid();\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    PolylineElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianArrayToLeafletsLatLngSchema.call(this);\n        //check if any of the two optional injections exist\n        if (this.LeafletElement || this.LeafletGroup) {\n            //polyline shouldn't have a fill\n            this.Options.fill = false;\n            var /** @type {?} */ inheritedOptions = new path(this.Options);\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            _super.prototype.transformArrayCoordinates.call(this, this.LeafletElement.crs);\n            this.polyline = L.polyline(this.latlngs, inheritedOptions);\n            if (this.LeafletGroup) {\n                this.groupService.addOLayersToGroup(this.polyline, map$$1, this.mapService, this.LeafletGroup, false, this.globalId);\n            }\n            else {\n                this.polyline.addTo(map$$1);\n            }\n        }\n        else {\n            console.warn(\"This polyline-element will not be rendered \\n the expected parent node of polyline-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PolylineElement.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ textInput = undefined;\n        if (this.ngEl.nativeElement.childNodes.length > 0) {\n            var /** @type {?} */ textNode = this.ngEl.nativeElement.childNodes[0];\n            textInput = textNode.nodeValue;\n        }\n        //add popup methods on element only if any of the tests are not undefined\n        if (this.mouseover !== undefined || this.onclick !== undefined || textInput !== undefined) {\n            this.popupService.enablePopup(this.mouseover, this.onclick, this.polyline, textInput);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    PolylineElement.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ map$$1 = this.mapService.getMap();\n        var /** @type {?} */ same = this.helperService.arrayCompare(this.originalObject, this.latlngs);\n        if (!same) {\n            this.originalObject = this.latlngs.slice();\n            //if the layer is part of a group\n            this.Options.fill = false;\n            var /** @type {?} */ inheritedOptions = new path(this.Options);\n            if (this.LeafletGroup) {\n                this.polyline = L.polyline(this.latlngs, inheritedOptions);\n                this.groupService.addOLayersToGroup(this.polyline, map$$1, this.mapService, this.LeafletGroup, true, this.globalId);\n            }\n            else {\n                map$$1.removeLayer(this.polyline);\n                this.polyline = L.polyline(this.latlngs, inheritedOptions);\n                this.polyline.addTo(map$$1);\n            }\n        }\n    };\n    PolylineElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'polyline-element',\n                    template: \"<div #ngel><ng-content></ng-content></div>\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    PolylineElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: PopupService, },\n        { type: GuidService, },\n        { type: HelperService, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    PolylineElement.propDecorators = {\n        \"latlngs\": [{ type: core.Input },],\n        \"Options\": [{ type: core.Input },],\n        \"mouseover\": [{ type: core.Input },],\n        \"onclick\": [{ type: core.Input },],\n        \"ngEl\": [{ type: core.ViewChild, args: ['ngel',] },],\n    };\n    return PolylineElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar GeoJsonElement = (function (_super) {\n    __extends(GeoJsonElement, _super);\n    function GeoJsonElement(mapService, popupService, guidService, helperService, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.popupService = popupService;\n        _this.guidService = guidService;\n        _this.helperService = helperService;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.originalObject = Object.assign({}, _this.geojson);\n        _this.globalId = _this.guidService.newGuid();\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    GeoJsonElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        //check if any of the two optional injections exist\n        if (this.LeafletElement || this.LeafletGroup) {\n            //polyline shouldn't have a fill\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            if (this.geojson) {\n                _super.prototype.transformJSONCoordinates.call(this, this.geojson, this.LeafletElement.crs);\n                var /** @type {?} */ gjson = L.geoJSON(this.geojson);\n                if (this.LeafletGroup) {\n                    this.groupService.addOLayersToGroup(gjson, map$$1, this.mapService, this.LeafletGroup, false, this.globalId);\n                }\n                else {\n                    gjson.addTo(map$$1);\n                }\n            }\n            else {\n                console.warn(\"geojson object seems to be undefined\");\n            }\n        }\n        else {\n            console.warn(\"This polyline-element will not be rendered \\n the expected parent node of polyline-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    /**\n     * @return {?}\n     */\n    GeoJsonElement.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ map$$1 = this.mapService.getMap();\n    };\n    GeoJsonElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'geojson-element',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    GeoJsonElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: PopupService, },\n        { type: GuidService, },\n        { type: HelperService, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    return GeoJsonElement;\n}(GeoJSONCoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar PopupElement = (function (_super) {\n    __extends(PopupElement, _super);\n    function PopupElement(mapService, groupService, LeafletElement$$1, LeafletGroup$$1) {\n        var _this = _super.call(this) || this;\n        _this.mapService = mapService;\n        _this.groupService = groupService;\n        _this.LeafletElement = LeafletElement$$1;\n        _this.LeafletGroup = LeafletGroup$$1;\n        _this.lat = 52.6;\n        _this.lon = -1.9;\n        _this.content = \"nice popup\";\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    PopupElement.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.assignCartesianPointToLeafletsLatLngSchema.call(this);\n        //check if any of the two optional injections exist\n        if (this.LeafletElement || this.LeafletGroup) {\n            var /** @type {?} */ map$$1 = this.mapService.getMap();\n            _super.prototype.transformPointCoordinates.call(this, this.LeafletElement.crs);\n            var /** @type {?} */ popup = L.popup({ autoClose: false, keepInView: true }).setLatLng([this.lat, this.lon]).setContent(/** @type {?} */ (this.content));\n            if (this.LeafletGroup) {\n                this.groupService.addOLayersToGroup(popup, map$$1, this.mapService, this.LeafletGroup);\n            }\n            else {\n                popup.addTo(map$$1);\n            }\n        }\n        else {\n            console.warn(\"This popup-element will not be rendered \\n the expected parent node of popup-element should be either leaf-element or leaflet-group\");\n        }\n    };\n    PopupElement.decorators = [\n        { type: core.Component, args: [{\n                    selector: 'popup-element',\n                    template: \"\",\n                    styles: ['']\n                },] },\n    ];\n    /** @nocollapse */\n    PopupElement.ctorParameters = function () { return [\n        { type: MapService, },\n        { type: GroupService, decorators: [{ type: core.Optional },] },\n        { type: LeafletElement, decorators: [{ type: core.Optional },] },\n        { type: LeafletGroup, decorators: [{ type: core.Optional },] },\n    ]; };\n    PopupElement.propDecorators = {\n        \"lat\": [{ type: core.Input },],\n        \"lon\": [{ type: core.Input },],\n        \"content\": [{ type: core.Input },],\n    };\n    return PopupElement;\n}(CoordinateHandler));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ngxLeafletModule = (function () {\n    function ngxLeafletModule() {\n    }\n    ngxLeafletModule.decorators = [\n        { type: core.NgModule, args: [{\n                    imports: [\n                        common.CommonModule,\n                        http.HttpModule\n                    ],\n                    declarations: [\n                        LeafletElement,\n                        AttributionControl,\n                        ScaleControl,\n                        ZoomControl,\n                        WatermarkControl,\n                        LayerElement,\n                        ImageOverlayElement,\n                        MarkerElement,\n                        CircleElement,\n                        CircleMarkerElement,\n                        PolygonElement,\n                        PolylineElement,\n                        GeoJsonElement,\n                        PopupElement,\n                        LeafletGroup\n                    ],\n                    providers: [\n                        PopupService,\n                        GuidService,\n                        HelperService\n                    ],\n                    exports: [\n                        LeafletElement,\n                        AttributionControl,\n                        ScaleControl,\n                        ZoomControl,\n                        WatermarkControl,\n                        LayerElement,\n                        ImageOverlayElement,\n                        MarkerElement,\n                        CircleElement,\n                        CircleMarkerElement,\n                        PolygonElement,\n                        PolylineElement,\n                        GeoJsonElement,\n                        PopupElement,\n                        LeafletGroup\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    ngxLeafletModule.ctorParameters = function () { return []; };\n    return ngxLeafletModule;\n}());\n\nexports.LeafletElement = LeafletElement;\nexports.CoordinateHandler = CoordinateHandler;\nexports.GeoJSONCoordinateHandler = GeoJSONCoordinateHandler;\nexports.AttributionControl = AttributionControl;\nexports.ScaleControl = ScaleControl;\nexports.ZoomControl = ZoomControl;\nexports.WatermarkControl = WatermarkControl;\nexports.LayerElement = LayerElement;\nexports.ImageOverlayElement = ImageOverlayElement;\nexports.MarkerElement = MarkerElement;\nexports.CircleElement = CircleElement;\nexports.CircleMarkerElement = CircleMarkerElement;\nexports.PolygonElement = PolygonElement;\nexports.PolylineElement = PolylineElement;\nexports.GeoJsonElement = GeoJsonElement;\nexports.PopupElement = PopupElement;\nexports.LeafletGroup = LeafletGroup;\nexports.MapService = MapService;\nexports.GroupService = GroupService;\nexports.PopupService = PopupService;\nexports.GuidService = GuidService;\nexports.HelperService = HelperService;\nexports.attributionModel = attributionModel;\nexports.path = path;\nexports.scaleModel = scaleModel;\nexports.zoomModel = zoomModel;\nexports.ngxLeafletModule = ngxLeafletModule;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}